Goal: to develop a solid library of classes and functions in which to
implement a robust, enjoyable, and graphically-modern 2d video game,
including network support.

MAJOR TASKS:
/ circle/polygon collision/entity areas
/ physics engine
- console command stuff
- console logger/debugging logger
? embedded scripting
- split world into client and server and add networking
- music and sound effects
/ map editor + sprite/entity prefab editor
/ comment/document the code with doxygen
- exceptions for user errors
/ x/y independent scaling (the physics portion of that is tough)
/ document the behavior of Widget, Layout, the Rendering stack,
  and all the other complicated systems.
- UI demonstration - every UI feature demonstrated in a series
  of tabbed widgets.
- abstraction of Engine2 classes into interfaces, to provide as
  much flexibility as possible, and to avoid biasing game physics, etc.
- ensure different areas of the engine are cleanly separated so that
  they could be compiled without others (i.e. core+engine could be
  used without gui or render, etc) -- make dependency chart

DISASTEROIDS:
** feature-related **
- make the 7 button just activate the EMP core, there's no reason to have
  to equip it and then fire
  OR
  add a spiralling-in ambient tractor beam secondary fire to EMP, so
  the player can suck in enemies and then blast them.
- merged grenades should have a higher threshold of detonation.  i.e.
  hitting something with more force or something heaver, or a bullet, etc.
- When a Mortal is being damaged by something it's strong, weak
  or immune against, it should make a particular sound to indicate that.
- forget the 4x item status screen.  upgrading should be one way,
  and the inventory should just show what level item it is.  this also
  means you can't skip buying a certain level of something.
  furthermore, make higher upgrade levels, so the madness can continue
- add key to dump shields into power cells
- make Devourment track who damaged it and how much, so it can retaliate
  against the ship that damaged it above a certain threshold.
- possibly make Devourment have a time-based health-recharge behavior, so you
  have to do heavy damage to it quickly to kill it.
  after the timer expires, have it pulse green to indicate it's healed
- make Demi push away if its taking too much damage and the player is close
- make smart ballistics not be canceled out by other ballistics (i'm thinking
  mainly of the pea-shooter shooting a full charge and getting canceled
  out by some puny other ballistic).
- make Shade circle around the player once it has locked on
- make Shade respond as a charged particle in a magnetic field if it's
  touching a tractor beam
- make Shade teleport or fly away if it takes too much damage
- add advanced behaviors for higher level enemies (like escaping Devourments)
- when a new high score is posted and you're taken back to the title screen,
  the just-added score should be highlighted or blinking somehow
- add collision_location and collision_normal to LineTrace
- referring to the accumulated force on an entity is uncertain.  there
  should be some sort of previous-frame accumulated force accessor,
  for functions that use it (e.g. intercept course stuff)
- split the physics and visibility computation up so their frame
  processing isn't dependent.  this requires addition of some "scale velocity"
  property on entities.  there will also be a problem with code that
  sets the position of entities (or sets any value) directly (this is a no-no
  in a linear-interpolation world).
- have the debris spawning in Mortal.  it should be done in Damage,
  and the subclasses of Mortal should specify the debris type (rocks,
  metal, minerals, blood, guts, etc).
- make enemies flash yellow when their health is low
- if super-stoke thing is added, that can be indicated by the ship flashing
  white or blue or something
- collapse the world and object layer params in spawning functions to just
  using the object layer (the world should be accessible through it).
- to limit the length of waves, there can be a time limit after which all
  the enemies are SetTarget'ed against the player (which can happen every
  few seconds, so the player can't just EMP them to escape).
- change gauss gun's fire rate to be based on how fast it can be charged back
  up by the power generator -- also, the fire sequence should start with the
  gun completely discharged.. holding the fire button down will then charge
  and fire it, as a reticle homes in on the mouse cursor to indicate when
  it will fire.  charge should be persistent, so if you let go of the fire
  button before the weapon discharged, it should save the power it accumulated.
  NOTE: this might require a redesign of the power generation system, because
  the amount of power to supply to the gauss gun will depend on how much
  power is available.
- split up high scores into difficulty levels
- change missiles: they should not be able to flip around at any angle, but
  only travel in circles (acceleration perpendicular to velocity).
  missiles should be made much heavier, so they're not deflected away by
  tractors as easily.
- add validation to Dis::Config modifiers
- add extra-power-to-the-shields powerup which would drain your power, but
  strengthen your shields significantly
- add "sprint" powerup (or maybe have it be built-in) which would make your
  engines use twice the power, but accelerate 1.5x or 2x or some factor
  better.
** sound-system-related **
- there should be a drone for the power generator -- max volume at 0%, zero
  volume at 100%, low frequency at 0%, high frequency at 100%.
- add drone for shields also?  or decide which of shields/power generator
  should have a drone.  maybe they can both have a drone, at obviously
  distinct frequencies.
** bugs **
- when setting options from the commandline, the options menu isn't updated
- the gauss gun damage location appears to be wrong (on exactly
  the opposite side of the damagee -- e.g. blowing up asteroids), and possibly
  the laser too.
- there seems to be a bug in the aiming in the front weapon of Demi
- get non-wrapped ObjectLayers back up and running (because they totally
  don't work in disasteroids)
- firing a laser or gauss gun while directly facing and touching e.g.
  an asteroid causes the line trace to fail so the weapon fires through
  the asteroid.  fix this by recording hits when the line starts inside
  objects, or start the line trace earlier and ignore the firer.
** general TODO **
- look into changing ScheduleForDeletion(0.0f) into RemoveFromWorld(), delete owner object
- look into changing ScheduleForRemovalFromWorld(0.0f) and RemoveFromWorld();
- handle wrapped space better and make the coordinate adjustment and such less fragile

TODO:
- handle failures (especially file loading failures) more gracefully
- use the same array for texture and vertex coords in Sprite (and maybe Polygon)
- it might be useful to re-implement SDL_ActiveEvent
- high framerates cause the impact damage to be too high in disasteroids (or maybe the impact damage is too low in low framerates)
- make GL::Shutdown function (and delete the opaque white texture which is currently leaked)
- use smallest acceptable data types in opengl calls (e.g. 4 bytes for RGBA,
  1 or 2 bytes for texture coords, etc)
- change ScreenCoord to use Sint16 instead of Sint32?  (this was tried, and there was a bug in drawing glyphs to parts of the screen, but is otherwise ready to be tried again).
- get rid of widget min/max size enabled flags, and just use the
  sizes (no min size = 0, no max size = (uint)-1)
- create consistent way to set z depth for non-transparent stuff so they're
  actually unique z depth values for each object.  maybe encode some sort
  of unique index into the least significant bits of the depth Float.
- have the application automatically change current working directory to
  the path of the executable (argv[0]).
- change Engine2::Compound to Engine2::Model ?
- make ~World detach attached WorldViews?  WorldView would then have to
  detect if m_world is NULL or not.
- in lesson04, make graphical representation of Engine2 design
- lesson07 - collision detection and resolution via PhysicsHandler
- lesson08 - user input or further subclassing of Entity
- bring livid stuff over and use its stuff (e.g. Sequence instead of dumb enums)
- somehow properly return both drawn opaque and transparent object counts from
  Engine2::ObjectLayer::Draw and make UI labels for them in the debug view.
- have SetPathElement... check for whitespace in the path
- add HandleDisabled/HandleEnabled and make Widget::SetIsEnabled not virtual
- ValueLabel and ValueEdit should take some sort of value-to-text function
  instead of a printf format (so it can be used to make vector ValueLabel/Edits)
- refactor the layout code to be more efficient (so it can handle really
  complex/huge layouts quickly)
- should Widget::Draw be protected?
- add a "mental note" advice-sort of section to the documents
- add @ref tags to appropriate places in lessons
- make the position given for text drawing be the left/center/right for
  left-justified, centered, or right-justified respectively, and same for
  vertical justification.  this will make arbitrary text drawing easier
- make picture labels use alignment properly
- make AsciiFont properly use UTF8
- resource library should not map resources to paths, but to sets of
  properties (the properties being one of many possible subclasses of some
  "property" baseclass).  this will allow loading of the same path for
  different things (among other extra versatilities).
- the framehandler time for WorldView must be synchronized with the
  framehandler time for World.  (depends on having the physics and
  visibility computation split up)
- add asserts to wrapped collision stuff to ensure things aren't above
  1/2 of the object side length
- do tab/shift-tab control of child widget focus
- should Screen make its own event queue?
- child widgets should be based off the position of their parents, so
  screen-relative moving is unnecessary.
- the map editor view should not create/destroy its own world -- it
  becomes confusing
- check if RemoveFromWorld() and AddBackIntoWorld() should save the quadtree(s)
- rename all enums to have prefixes (where appropriate)
- drawing functions should all just push the modelview matrix, not load
  the identity (except for top-level ones like Screen and such).
- compound editing operations: delete vertices, delete polygons, flip polygons,
  flip objects, unweld polygon vertices, clone polygons, splitting polygons
- for static Create type functions for subclassable classes, see if the
  function can be templatized so that each subclass doesn't have to make
  a function that is identical except for the "new Blah" part.
- change BinarySerializer and BitCache to use IODirection enum instead of
  retarded stdio file mode string in Open.
- cursor position in map editor status bar
- when the Action system is written, go into MapEditor2::WorldView and
  convert everything to that, and get rid of locally tracking
  m_selected_entity_count and friends.
- possibly make a Math::Radian namespace to contain properly typed
  versions of the trig functions which take radian angles.
- for overridable Widget methods, make it so that subclasses don't
  have to call anything to maintain widget functionality.
- add DeleteSelf to Widget baseclass as a means for scheduling itself
  for deletion.
- add HandleEnabled and HandleDisabled to Widget ?
- add HandleHidden and HandleShown to Widget ?
- verify that when a mouse-grabbed widget is deleted, it un-mouse-grabs
- verify that focusing a widget contained in a widget with m_accepts_focus
  set to false will not change the focus line.
- change the names of the vertex/compound selection functions in
  MapEditor2::ObjectLayer to indicate they only operate within the
  scope of the object selection set.
- verify that the operator overloads for math constructs (e.g. Vector)
  work when "using namespace Xrb" is not used.
- think about MapEditor2::MainWidget and if the Widget's main widget
  functionality should be renamed.
- make the map editor use only meta-keyed shortcuts so that handling
  key events is much simpler.
- add modal widget frame/content margins (maybe just make it so that
  setting a main widget puts stuff inside the content margins)
- for widgets who take the default property a single time at the beginning,
  make it so they keep updating their property with the WidgetSkin,
  but if you manually set the property to something else, then it will stay
  different and not update with the WidgetSkin.
- make the content margins based at the edge of the widget, instead
  of the frame margins.
- add type-specific range checking for WidgetSkin properties.
- remember the C++ typeid/type_info stuff.
- think up a way to draw entity metrics which show if an entity
  applies and reacts to gravity.
- density might apply to selection sets (i.e. scaling the relative density)
- density is a little wacky -- fix it.
- do real entity area computation for density and other calculations.
- make the view grid display set units, rather than fractions of
  the size of the object layers.
- improve the text-editing control of LineEdit (e.g. ctrl+backspace,
  point-and-click cursor positioning, text selection, etc).
- in map editor, make the scale/angle resetting code when changing
  transformation modes be optional.
- implement FastXXXX Math functions
- the resource instance should store the function that was created
  to create the resource data so that full correctness can be
  achieved.
- GL singleton should have checks to see if it's been initialized
  so when gl calls fail mysteriously, it's obvious what happened.
- hide the defer-parent-update SetSizeProperty* versions and make public
  versions of each without that parameter.
- change the IOE_IS_AT_END checking for how many bytes/bits are left
- support for bit depths besides 32
- WidgetSkin properties for checkbox/radiobutton/toolbar button sizes
- maybe WidgetBackground should provide the FrameMargins and ContentMargins
- make WidgetSkin properties data-driven and/or use events for the
  multiplexed functions.
- change all functions which accept a bool or int as a type of something
  or a behavior to use enums instead, to make code more self-documenting.
- special Vector2 ValueEdit
- add menu/popup system and menu items
- move keyboard shortcuts into 'actions' similar to QT, which menu items
  and normal functions can use.
- tabbed widget layout
- use idea of 'render' or 'focus' object layer instead of 'main'
  object layer in world so that the nomenclature of the stuff in
  MapEditorWorld is a little more clear
- for accessors that return a member pointer, think about which ones
  should be made into "Blah const *"
- make a handy Util function which does quantizing
- add a 'time type' which allows changing of what data type actually
  stores times (i.e. ints or floats, etc)
- look into normal mapping to give lighting effects
- make all drawing functions const (if possible)
- add smart usage of newline indexed data in Label, so that it could
  be used for very large texts
- change the 'distance culling' for sprite drawing in quadtrees
  to use a configurable setting, so that the size at which to cull
  sprites can be changed for performance
- do some sort of video refresh synchronizing so the display
  looks smoother

GAME IDEAS:
- different types of ships should have different limitations on propulsion,
  e.g. a rocket should only be able turn and go forward, while a flying saucer
  should be able to move in any direction.
- have a bunch of navigational and calculation tools, like things to calculate
  the speed to enter orbit, the distance to an entity, etc
- have a bunch of displays such as coordinates relative to an entity,
  distance from an entity, relative speed, a circle around a planet which
  shows the orbit for a particular speed, etc
- calculations so that ships could enter orbit of a planet at different
  heights, also geosynchronous
- make a level which is a galaxy-shaped series of nebula and star sprites,
  and is characatured with large planets in the spiral arms of the galaxy
- deflector shield which applies force on offending particles using a vector
  field.  the forces which it applies will drain units' energy
- wormholes
- planetary shields
- planetary movement engines (so you can change the orbits/trajectories of
  moons, planets and asteroids)
- inertia-less upgrade, so that units can instantly accelerate to a constant
  speed, or hover effortlessly without gravity affecting them
- special black hole sprite that warps the background image in the same
  manner as a real blackhole (have to rewrite my thesis program for this)
--- platformer
- normal and "ice" shoes - for different ground friction
- point-and-teleport gun
- grappling hook gun
- tractor beam gun
