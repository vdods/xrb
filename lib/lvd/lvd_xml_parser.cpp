// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// lvd_xml_parser.cpp generated by trison
// from lvd_xml_parser.trison using trison.cpp.targetspec and trison.cpp.implementation.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "lvd_xml_parser.hpp"


#define TRISON_CPP_DEBUG_CODE_(spew_code) if (DebugSpew()) { spew_code; }


#line 82 "lvd_xml_parser.trison"

#include <lvd_xml.hpp>
#include <lvd_xml_scanner.hpp>
#include <sstream>

using namespace std;

namespace Lvd {
namespace Xml {

#line 24 "lvd_xml_parser.cpp"

Parser::Parser ()
    :

#line 92 "lvd_xml_parser.trison"

    m_scanner(*new Scanner())

#line 33 "lvd_xml_parser.cpp"
{
    DebugSpew(false);
}

Parser::~Parser ()
{
    // clean up dynamically allocated memory.
    ClearStack_();
    ClearLookaheadQueue_();



#line 95 "lvd_xml_parser.trison"

    delete &m_scanner;

#line 50 "lvd_xml_parser.cpp"
}

bool Parser::IsAtEndOfInput ()
{
    return Lookahead_(0).m_id == Terminal::END_;
}

void Parser::ResetForNewInput ()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 63 "lvd_xml_parser.cpp"
 << " executing reset-for-new-input actions" << std::endl)

    // clean up stuff that might be hanging around from the last parse's input.
    ClearStack_();
    ClearLookaheadQueue_();


#line 199 "lvd_xml_parser.trison"

    m_scanner.ResetForNewInput();

#line 75 "lvd_xml_parser.cpp"
}

Parser::ParserReturnCode Parser::Parse (DomNode * *return_token, ParseNonterminal::Name nonterminal_to_parse)
{
    return Parse_(return_token, nonterminal_to_parse);
}

// ///////////////////////////////////////////////////////////////////////
// begin internal trison-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

Parser::ParserReturnCode Parser::Parse_ (DomNode * *return_token, ParseNonterminal::Name nonterminal_to_parse)
{
    assert(return_token != NULL && "the return-token pointer must be non-NULL");

    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 94 "lvd_xml_parser.cpp"
 << " starting parse" << std::endl)

    ParserReturnCode parser_return_code_ = PRC_UNHANDLED_PARSE_ERROR;
    *return_token = NULL;

    // make sure all our structures are empty and variables initialized.
    // we don't clear the lookahead queue here because we might want to
    // parse multiple times from the same input, and the lookahead queue
    // could have the next few tokens in it.
    ClearStack_();
    m_is_in_error_panic_ = false;

    // push the initial state of the DPDA.
    assert((false
           || nonterminal_to_parse == ParseNonterminal::attribute_list
           || nonterminal_to_parse == ParseNonterminal::document
           || nonterminal_to_parse == ParseNonterminal::element
           || nonterminal_to_parse == ParseNonterminal::element_list
           || nonterminal_to_parse == ParseNonterminal::end_tag
           || nonterminal_to_parse == ParseNonterminal::processing_instruction
           || nonterminal_to_parse == ParseNonterminal::selfended_tag
           || nonterminal_to_parse == ParseNonterminal::start_tag
           ) && "invalid nonterminal_to_parse");
    m_stack_.push_back(StackElement_(nonterminal_to_parse, NULL));
    // main parser loop
    while (true)
    {
        if (m_is_in_error_panic_)
        {
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 127 "lvd_xml_parser.cpp"
 << " begin error panic" << std::endl)

            while (true)
            {
                // get the current state (top of the stack)
                assert(!m_stack_.empty());
                BarfCpp_::Uint32 current_state_index = m_stack_.rbegin()->m_state_index;
                assert(current_state_index < ms_state_count_);
                State_ const &current_state = ms_state_table_[current_state_index];
                TRISON_CPP_DEBUG_CODE_(PrintParserStatus_(std::cerr))

                // check if the current state accepts ERROR_ (only need to check the
                // non-default transitions, since the default transition can't be a shift).
                bool accepts_error = false;
                for (Transition_ const *transition = current_state.m_transition_table+1, // +1 because the first is the default
                                       *transition_end = current_state.m_transition_table+current_state.m_transition_count;
                     transition != transition_end;
                     ++transition)
                {
                    if (transition->m_type == Transition_::SHIFT && transition->m_lookahead_count == 1 && *transition->m_lookahead_sequence == Terminal::ERROR_)
                    {
                        accepts_error = true;
                        break;
                    }
                }

                if (accepts_error)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 159 "lvd_xml_parser.cpp"
 << " end error panic; success (current state accepts ERROR_ token)" << std::endl)
                    // if the current state accepts error, then we check if the lookahead token
                    // is Terminal::END_.  if it is, then we add a dummy Terminal::ERROR_ token
                    // in before it (since %error can't accept END_).  otherwise, we throw away
                    // the lookahead token, then clear the thrown-away token data, and set the
                    // token id to ERROR_.
                    assert(!m_lookahead_queue_.empty());
                    if (m_lookahead_queue_[0].m_id == Terminal::END_)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 172 "lvd_xml_parser.cpp"
 << " deferring Terminal::END_ (padding with Terminal::ERROR_ token)" << std::endl)
                        m_lookahead_queue_.push_front(Token(Terminal::END_)); // dummy value
                    }
                    else
                        ThrowAwayToken_(m_lookahead_queue_[0].m_data);
                    m_lookahead_queue_[0].m_id = Terminal::ERROR_;
                    m_lookahead_queue_[0].m_data = NULL;
                    m_is_in_error_panic_ = false;
                    break;
                }
                else
                {
                    if (m_stack_.size() > 1)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 190 "lvd_xml_parser.cpp"
 << " continue error panic; pop stack (current state doesn't accept ERROR_ token)" << std::endl)
                    }
                    else
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 198 "lvd_xml_parser.cpp"
 << " end error panic; abort (stack is empty)" << std::endl)
                    }
                    // otherwise throw away the data at the top of the stack, and pop the stack.
                    // then if the stack is empty, an unhandled parse error occurred.
                    ThrowAwayToken_(m_stack_.rbegin()->m_token_data);
                    m_stack_.resize(m_stack_.size()-1);
                    if (m_stack_.empty())
                    {
                        // parser_return_code_ and return_token are already appropriately
                        // set, so just break out of the inner loop.
                        break;
                    }
                }
            }

            // if we're still in error panic, then this indicates that we bottomed-
            // out the stack and it's an unhandled parse error, so break from the
            // main loop.
            if (m_is_in_error_panic_)
                break;
        }
        else // !m_is_in_error_panic_
        {
            // get the current state (top of the stack)
            assert(!m_stack_.empty());
            BarfCpp_::Uint32 current_state_index = m_stack_.rbegin()->m_state_index;
            assert(current_state_index < ms_state_count_);
            State_ const &current_state = ms_state_table_[current_state_index];
            TRISON_CPP_DEBUG_CODE_(PrintParserStatus_(std::cerr))

            // TODO -- binary search for faster transition matching?

            // loop through the current state's transitions and see if any match
            bool transition_exercised = false;
            BarfCpp_::Uint32 tested_lookahead_count = 0;
            for (Transition_ const *transition = current_state.m_transition_table+1, // +1 because the first is the default
                                   *transition_end = current_state.m_transition_table+current_state.m_transition_count;
                transition != transition_end;
                ++transition)
            {
                // the non-default transitions can only be REDUCE or SHIFT
                assert(transition->m_type == Transition_::REDUCE || transition->m_type == Transition_::SHIFT);

                // check if the lookaheads match those of this transition.
                bool lookahead_sequence_matched = true;
                for (BarfCpp_::Uint32 i = 0; i < transition->m_lookahead_count; ++i)
                {
                    if (Lookahead_(i).m_id != transition->m_lookahead_sequence[i])
                    {
                        lookahead_sequence_matched = false;
                        break;
                    }
                    else
                    {
                        if (i+1 > tested_lookahead_count)
                            tested_lookahead_count = i+1;
                    }
                }

                // if all the lookaheads matched, then exercise this transition,
                // and break out of this inner (transition) loop.
                if (lookahead_sequence_matched)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 265 "lvd_xml_parser.cpp"
 << " currently usable lookahead(s):")
                    for (BarfCpp_::Uint32 i = 0; i < tested_lookahead_count; ++i)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << ' ' << Lookahead_(i))
                    }
                    TRISON_CPP_DEBUG_CODE_(std::cerr << std::endl)

                    ExerciseTransition_(*transition);
                    transition_exercised = true;
                    break;
                }
            }

            // if no transition was exercised, then exercise the default transition
            if (!transition_exercised)
            {
                TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 285 "lvd_xml_parser.cpp"
 << " currently usable lookahead(s):")
                for (BarfCpp_::Uint32 i = 0; i < tested_lookahead_count; ++i)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << ' ' << Lookahead_(i))
                }
                TRISON_CPP_DEBUG_CODE_(std::cerr << std::endl)

                TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 296 "lvd_xml_parser.cpp"
 << " exercising default transition" << std::endl)
                // exercise the default transition.  a return value of true indicates
                // that the parser should return.
                if (ExerciseTransition_(*current_state.m_transition_table))
                {
                    // the token (data) on the top of the stack is the return token.
                    // set parser_return_code_ and assign the top stack token data to
                    // *return_token and then break out of the main parser loop.
                    assert(m_stack_[0].m_state_index == BarfCpp_::Uint32(nonterminal_to_parse));
                    assert(m_stack_.size() == 2);
                    parser_return_code_ = PRC_SUCCESS;
                    *return_token = m_stack_.rbegin()->m_token_data;
                    // take the return token out of the stack, so it's not thrown away
                    // when we clear the stack later.
                    m_stack_.rbegin()->m_token_data = NULL;
                    break;
                }
            }
        }
    }

    // clear the stack, because we won't need it for the next parse.
    // we don't clear the lookahead queue here because we might want to
    // parse multiple times from the same input, and the lookahead queue
    // could have the next few tokens in it.
    ClearStack_();

    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_SUCCESS) std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 327 "lvd_xml_parser.cpp"
 << " Parse() is returning PRC_SUCCESS" << std::endl)
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_UNHANDLED_PARSE_ERROR) std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 332 "lvd_xml_parser.cpp"
 << " Parse() is returning PRC_UNHANDLED_PARSE_ERROR" << std::endl)

    return parser_return_code_;
}

void Parser::ThrowAwayToken_ (Token::Data &token_data) throw()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 343 "lvd_xml_parser.cpp"
 << " executing throw-away-token actions" << std::endl)


#line 193 "lvd_xml_parser.trison"

    delete token_data;

#line 351 "lvd_xml_parser.cpp"
}

Parser::Token Parser::Scan_ () throw()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 359 "lvd_xml_parser.cpp"
 << " executing scan actions" << std::endl)


#line 196 "lvd_xml_parser.trison"

    return m_scanner.Scan();

#line 367 "lvd_xml_parser.cpp"
}

void Parser::ClearStack_ () throw()
{
    if (m_stack_.empty())
        return; // nothing to do

    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 378 "lvd_xml_parser.cpp"
 << " clearing the stack" << std::endl)

    Stack_::iterator it = m_stack_.begin();
    Stack_::iterator it_end = m_stack_.end();
    // skip the bottom of the stack, since it
    // contains the start state and no token data.
    ++it;
    for ( ; it != it_end; ++it)
        ThrowAwayToken_(it->m_token_data);
    m_stack_.clear();
}

void Parser::ClearLookaheadQueue_ () throw()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 396 "lvd_xml_parser.cpp"
 << " clearing the lookahead queue" << std::endl)

    for (LookaheadQueue_::iterator it = m_lookahead_queue_.begin(), it_end = m_lookahead_queue_.end(); it != it_end; ++it)
        ThrowAwayToken_(it->m_data);
    m_lookahead_queue_.clear();
}

Parser::Token const &Parser::Lookahead_ (LookaheadQueue_::size_type index) throw()
{
    while (index >= m_lookahead_queue_.size())
    {
        m_lookahead_queue_.push_back(Scan_());

        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 413 "lvd_xml_parser.cpp"
 << " pushed " << *m_lookahead_queue_.rbegin() << " onto back of lookahead queue" << std::endl)
    }
    return m_lookahead_queue_[index];
}

bool Parser::ExerciseTransition_ (Transition_ const &transition)
{
    switch (transition.m_type)
    {
        case Transition_::REDUCE:
        {
            // execute the indicated reduction rule, push the returned Token
            // onto the front of the lookahead queue, then pop the corresponding
            // number of stack elements.
            assert(transition.m_data < ms_rule_count_);
            Rule_ const &rule = ms_rule_table_[transition.m_data];
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 433 "lvd_xml_parser.cpp"
 << " REDUCE " << rule.m_description << std::endl)
            assert(m_stack_.size() > rule.m_token_count);
            m_lookahead_queue_.push_front(
                Token(
                    rule.m_reduction_nonterminal_token_id,
                    ExecuteReductionRule_(transition.m_data)));
            m_stack_.resize(m_stack_.size() - rule.m_token_count);
            assert(rule.m_reduction_nonterminal_token_id < ms_token_name_count_);
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 445 "lvd_xml_parser.cpp"
 << " pushed " << Token(rule.m_reduction_nonterminal_token_id) << " onto front of lookahead queue" << std::endl)
            return false; // indicating the parser isn't returning
        }

        case Transition_::RETURN:
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 454 "lvd_xml_parser.cpp"
 << " RETURN" << std::endl)
            return true; // indicating the parser is returning

        case Transition_::SHIFT:
            // push the state (indicated by the shift transition) and token data
            // onto the stack, then pop the corresponding lookahead.
            assert(transition.m_data < ms_state_count_);
            assert(Lookahead_(0).m_id < ms_token_name_count_); // at this point, we're past a possible
                                                               // client error, so asserting here is ok.
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 467 "lvd_xml_parser.cpp"
 << " SHIFT " << Lookahead_(0) << std::endl)
            m_stack_.push_back(StackElement_(transition.m_data, Lookahead_(0).m_data));
            m_lookahead_queue_.pop_front();
            return false; // indicating the parser isn't returning

        case Transition_::ERROR_PANIC:
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 477 "lvd_xml_parser.cpp"
 << " ERROR_PANIC" << std::endl)
            m_is_in_error_panic_ = true;
            return false; // indicating the parser isn't returning

        default:
            assert(false && "invalid transition type (bad state machine, or memory corruption)");
            return false; // indicating the parser isn't returning
    }
}

Parser::Token::Data Parser::ExecuteReductionRule_ (BarfCpp_::Uint32 const rule_index_) throw()
{
    assert(rule_index_ < ms_rule_count_);
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 494 "lvd_xml_parser.cpp"
 << " executing reduction rule " << rule_index_ << std::endl)
    switch (rule_index_)
    {
        default:
            assert(false && "this should never happen");
            return NULL;

        case 0:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Document * list(static_cast<Document *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 232 "lvd_xml_parser.trison"

        return list;
    
#line 511 "lvd_xml_parser.cpp"
            break;
        }

        case 1:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Document * list(static_cast<Document *>(m_stack_[m_stack_.size()-2].m_token_data));
            Element * element(static_cast<Element *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 240 "lvd_xml_parser.trison"

        list->m_element.push_back(element);
        return list;
    
#line 526 "lvd_xml_parser.cpp"
            break;
        }

        case 2:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Document * list(static_cast<Document *>(m_stack_[m_stack_.size()-2].m_token_data));
            Text * text(static_cast<Text *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 246 "lvd_xml_parser.trison"

        list->m_element.push_back(text);
        return list;
    
#line 541 "lvd_xml_parser.cpp"
            break;
        }

        case 3:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 252 "lvd_xml_parser.trison"

        return new Document();
    
#line 553 "lvd_xml_parser.cpp"
            break;
        }

        case 4:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * pi(static_cast<Element *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 260 "lvd_xml_parser.trison"

        return pi;
    
#line 566 "lvd_xml_parser.cpp"
            break;
        }

        case 5:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * start_tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));
            Document * element_list(static_cast<Document *>(m_stack_[m_stack_.size()-2].m_token_data));
            Element * end_tag(static_cast<Element *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 265 "lvd_xml_parser.trison"

        if (start_tag->m_name != "%error" && end_tag->m_name != "%error" && start_tag->m_name != end_tag->m_name)
            EmitError("end-tag '" + end_tag->m_name + "' doesn't match start-tag '" + start_tag->m_name + "'", end_tag->m_filoc);
        // steal the contents of the element list
        assert(start_tag->m_element.empty());
        start_tag->m_element.swap(element_list->m_element);
        delete element_list;
        delete end_tag;
        return start_tag;
    
#line 588 "lvd_xml_parser.cpp"
            break;
        }

        case 6:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * start_tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));
            Element * end_tag(static_cast<Element *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 277 "lvd_xml_parser.trison"

        EmitError("parse error in element list in tag" + (start_tag->m_name != "%error" ? " '" + start_tag->m_name + "'" : ""), start_tag->m_filoc);
        if (start_tag->m_name != "%error" && end_tag->m_name != "%error" && start_tag->m_name != end_tag->m_name)
            EmitError("end-tag '" + end_tag->m_name + "' doesn't match start-tag '" + start_tag->m_name + "'", end_tag->m_filoc);
        delete end_tag;
        return start_tag;
    
#line 606 "lvd_xml_parser.cpp"
            break;
        }

        case 7:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * start_tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 286 "lvd_xml_parser.trison"

        EmitError("no matching end-tag for start-tag" + (start_tag->m_name != "%error" ? " '" + start_tag->m_name + "'" : ""), start_tag->m_filoc);
        return start_tag;
    
#line 620 "lvd_xml_parser.cpp"
            break;
        }

        case 8:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 292 "lvd_xml_parser.trison"

        return tag;
    
#line 633 "lvd_xml_parser.cpp"
            break;
        }

        case 9:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * end_tag(static_cast<Element *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 297 "lvd_xml_parser.trison"

        EmitError("end-tag" + (end_tag->m_name != "%error" ? " '" + end_tag->m_name + "'" : "") + " with no matching start-tag", end_tag->m_filoc);
        return end_tag;
    
#line 647 "lvd_xml_parser.cpp"
            break;
        }

        case 10:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * throwaway(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));
            Element * attribute_list(static_cast<Element *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 306 "lvd_xml_parser.trison"

        Element *pi = new Element(name->m_text, DomNode::PROCESSING_INSTRUCTION, name->m_filoc);
        // steal the attribute list
        pi->m_attribute.swap(attribute_list->m_attribute);
        delete throwaway;
        delete name;
        delete attribute_list;
        return pi;
    
#line 668 "lvd_xml_parser.cpp"
            break;
        }

        case 11:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 317 "lvd_xml_parser.trison"

        EmitError("parse error in processing instruction '" + name->m_text + "'", name->m_filoc);
        // rename the OPEN_PI tag and use it
        tag->m_name = name->m_text;
        tag->m_filoc = name->m_filoc;
        assert(tag->m_type == DomNode::PROCESSING_INSTRUCTION);
        delete name;
        return tag;
    
#line 688 "lvd_xml_parser.cpp"
            break;
        }

        case 12:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 328 "lvd_xml_parser.trison"

        EmitError("unterminated processing instruction '" + name->m_text + "'", name->m_filoc);
        // rename the OPEN_PI tag and use it
        tag->m_name = name->m_text;
        tag->m_filoc = name->m_filoc;
        assert(tag->m_type == DomNode::PROCESSING_INSTRUCTION);
        delete name;
        return tag;
    
#line 708 "lvd_xml_parser.cpp"
            break;
        }

        case 13:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 339 "lvd_xml_parser.trison"

        EmitError("parse error in processing instruction", tag->m_filoc);
        tag->m_name = "%error";
        assert(tag->m_type == DomNode::PROCESSING_INSTRUCTION);
        return tag;
    
#line 724 "lvd_xml_parser.cpp"
            break;
        }

        case 14:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 347 "lvd_xml_parser.trison"

        EmitError("unterminated processing instruction", tag->m_filoc);
        tag->m_name = "%error";
        assert(tag->m_type == DomNode::PROCESSING_INSTRUCTION);
        return tag;
    
#line 740 "lvd_xml_parser.cpp"
            break;
        }

        case 15:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * throwaway(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * opening_name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));
            Element * attribute_list(static_cast<Element *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 358 "lvd_xml_parser.trison"

        Element *element = new Element(opening_name->m_text, DomNode::ELEMENT, opening_name->m_filoc);
        // steal the attribute list
        element->m_attribute.swap(attribute_list->m_attribute);
        delete throwaway;
        delete opening_name;
        delete attribute_list;
        return element;
    
#line 761 "lvd_xml_parser.cpp"
            break;
        }

        case 16:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * opening_name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 369 "lvd_xml_parser.trison"

        EmitError("parse error in start-tag '" + opening_name->m_text + "'", opening_name->m_filoc);
        // rename the OPEN_TAG tag and use it
        tag->m_name = opening_name->m_text;
        tag->m_filoc = opening_name->m_filoc;
        assert(tag->m_type == DomNode::ELEMENT);
        delete opening_name;
        return tag;
    
#line 781 "lvd_xml_parser.cpp"
            break;
        }

        case 17:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * opening_name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 380 "lvd_xml_parser.trison"

        EmitError("unterminated start-tag '" + opening_name->m_text + "'", opening_name->m_filoc);
        // rename the OPEN_TAG tag and use it
        tag->m_name = opening_name->m_text;
        tag->m_filoc = opening_name->m_filoc;
        assert(tag->m_type == DomNode::ELEMENT);
        delete opening_name;
        return tag;
    
#line 801 "lvd_xml_parser.cpp"
            break;
        }

        case 18:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 391 "lvd_xml_parser.trison"

        EmitError("parse error in start-tag", tag->m_filoc);
        tag->m_name = "%error";
        assert(tag->m_type == DomNode::ELEMENT);
        return tag;
    
#line 817 "lvd_xml_parser.cpp"
            break;
        }

        case 19:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 399 "lvd_xml_parser.trison"

        EmitError("unterminated start-tag", tag->m_filoc);
        tag->m_name = "%error";
        assert(tag->m_type == DomNode::ELEMENT);
        return tag;
    
#line 833 "lvd_xml_parser.cpp"
            break;
        }

        case 20:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));
            Text * closing_name(static_cast<Text *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 410 "lvd_xml_parser.trison"

        // rename the OPEN_END_TAG tag and use it
        tag->m_name = closing_name->m_text;
        tag->m_filoc = closing_name->m_filoc;
        assert(tag->m_type == DomNode::ELEMENT);
        delete closing_name;
        return tag;
    
#line 852 "lvd_xml_parser.cpp"
            break;
        }

        case 21:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * closing_name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 420 "lvd_xml_parser.trison"

        EmitError("parse error in end-tag '" + closing_name->m_text + "'", closing_name->m_filoc);
        // rename the OPEN_END_TAG tag and use it
        tag->m_name = closing_name->m_text;
        tag->m_filoc = closing_name->m_filoc;
        assert(tag->m_type == DomNode::ELEMENT);
        delete closing_name;
        return tag;
    
#line 872 "lvd_xml_parser.cpp"
            break;
        }

        case 22:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * closing_name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 431 "lvd_xml_parser.trison"

        EmitError("unterminated end-tag '" + closing_name->m_text + "'", closing_name->m_filoc);
        // rename the OPEN_END_TAG tag and use it
        tag->m_name = closing_name->m_text;
        tag->m_filoc = closing_name->m_filoc;
        assert(tag->m_type == DomNode::ELEMENT);
        delete closing_name;
        return tag;
    
#line 892 "lvd_xml_parser.cpp"
            break;
        }

        case 23:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 442 "lvd_xml_parser.trison"

        EmitError("parse error in end-tag", tag->m_filoc);
        assert(tag->m_type == DomNode::ELEMENT);
        return tag;
    
#line 907 "lvd_xml_parser.cpp"
            break;
        }

        case 24:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 449 "lvd_xml_parser.trison"

        EmitError("unterminated end-tag", tag->m_filoc);
        assert(tag->m_type == DomNode::ELEMENT);
        return tag;
    
#line 922 "lvd_xml_parser.cpp"
            break;
        }

        case 25:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * throwaway(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));
            Element * attribute_list(static_cast<Element *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 459 "lvd_xml_parser.trison"

        Element *element = new Element(name->m_text, DomNode::ELEMENT, name->m_filoc);
        // steal the attribute list
        element->m_attribute.swap(attribute_list->m_attribute);
        delete throwaway;
        delete name;
        delete attribute_list;
        return element;
    
#line 943 "lvd_xml_parser.cpp"
            break;
        }

        case 26:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 470 "lvd_xml_parser.trison"

        EmitError("parse error in self-ended tag '" + name->m_text + "'", name->m_filoc);
        // rename the OPEN_TAG tag and use it
        tag->m_name = name->m_text;
        tag->m_filoc = name->m_filoc;
        assert(tag->m_type == DomNode::ELEMENT);
        delete name;
        return tag;
    
#line 963 "lvd_xml_parser.cpp"
            break;
        }

        case 27:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * tag(static_cast<Element *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 484 "lvd_xml_parser.trison"

        EmitError("parse error in self-ended tag", tag->m_filoc);
        tag->m_name = "%error";
        assert(tag->m_type == DomNode::ELEMENT);
        return tag;
    
#line 979 "lvd_xml_parser.cpp"
            break;
        }

        case 28:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * list(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));
            Text * value(static_cast<Text *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 498 "lvd_xml_parser.trison"

        if (list->m_attribute.find(name->m_text) != list->m_attribute.end())
            EmitError("duplicate attribute name " + name->m_text, name->m_filoc);
        else
            list->m_attribute[name->m_text] = value->m_text;
        delete name;
        delete value;
        return list;
    
#line 1000 "lvd_xml_parser.cpp"
            break;
        }

        case 29:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Element * list(static_cast<Element *>(m_stack_[m_stack_.size()-4].m_token_data));
            Text * name(static_cast<Text *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 509 "lvd_xml_parser.trison"

        EmitError("parse error in value of attribute " + name->m_text, name->m_filoc);
        if (list->m_attribute.find(name->m_text) != list->m_attribute.end())
            EmitError("duplicate attribute " + name->m_text, name->m_filoc);
        delete name;
        return list;
    
#line 1018 "lvd_xml_parser.cpp"
            break;
        }

        case 30:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 518 "lvd_xml_parser.trison"

        return new Element("");
    
#line 1030 "lvd_xml_parser.cpp"
            break;
        }

    }

    assert(false && "no value returned from reduction rule code block");
    return NULL;
}

void Parser::PrintParserStatus_ (std::ostream &stream) const
{
    assert(!m_stack_.empty());

    stream << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 1047 "lvd_xml_parser.cpp"
 << " parser stack: ";
    for (Stack_::const_iterator it = m_stack_.begin(), it_end = m_stack_.end(); it != it_end; ++it)
    {
        stream << it->m_state_index;
        Stack_::const_iterator next_it = it;
        if (++next_it != it_end)
            stream << ' ';
    }
    stream << std::endl;

    PrintIndented_(stream, ms_state_table_[m_stack_.rbegin()->m_state_index].m_description);
    stream << std::endl;
}

void Parser::PrintIndented_ (std::ostream &stream, char const *string) const
{
    assert(string != NULL);
    stream << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 1068 "lvd_xml_parser.cpp"
 << "    ";
    while (*string != '\0')
    {
        if (*string == '\n')
            stream << '\n' << 
#line 208 "lvd_xml_parser.trison"
"Lvd::Xml::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : "") << ":"
#line 1076 "lvd_xml_parser.cpp"
 << "    ";
        else
            stream << *string;
        ++string;
    }
}

std::ostream &operator << (std::ostream &stream, Parser::Token const &token)
{
    if (token.m_id < Parser::ms_token_name_count_)
        stream << '(' << Parser::ms_token_name_table_[token.m_id] << ')';
    else
        stream << "!INVALID TOKEN!";
    return stream;
}

Parser::Rule_ const Parser::ms_rule_table_[] =
{
    { Parser::Nonterminal_::document, 2, "document <- element_list END_" },
    { Parser::Nonterminal_::element_list, 2, "element_list <- element_list element" },
    { Parser::Nonterminal_::element_list, 2, "element_list <- element_list TEXT" },
    { Parser::Nonterminal_::element_list, 0, "element_list <-" },
    { Parser::Nonterminal_::element, 1, "element <- processing_instruction" },
    { Parser::Nonterminal_::element, 3, "element <- start_tag element_list end_tag" },
    { Parser::Nonterminal_::element, 3, "element <- start_tag ERROR_ end_tag" },
    { Parser::Nonterminal_::element, 3, "element <- start_tag ERROR_ END_" },
    { Parser::Nonterminal_::element, 1, "element <- selfended_tag" },
    { Parser::Nonterminal_::element, 1, "element <- end_tag" },
    { Parser::Nonterminal_::processing_instruction, 4, "processing_instruction <- OPEN_PI NAME attribute_list CLOSE_PI" },
    { Parser::Nonterminal_::processing_instruction, 4, "processing_instruction <- OPEN_PI NAME ERROR_ CLOSE_PI" },
    { Parser::Nonterminal_::processing_instruction, 4, "processing_instruction <- OPEN_PI NAME ERROR_ END_" },
    { Parser::Nonterminal_::processing_instruction, 3, "processing_instruction <- OPEN_PI ERROR_ CLOSE_PI" },
    { Parser::Nonterminal_::processing_instruction, 3, "processing_instruction <- OPEN_PI ERROR_ END_" },
    { Parser::Nonterminal_::start_tag, 4, "start_tag <- OPEN_TAG NAME attribute_list CLOSE_TAG" },
    { Parser::Nonterminal_::start_tag, 4, "start_tag <- OPEN_TAG NAME ERROR_ CLOSE_TAG" },
    { Parser::Nonterminal_::start_tag, 4, "start_tag <- OPEN_TAG NAME ERROR_ END_" },
    { Parser::Nonterminal_::start_tag, 3, "start_tag <- OPEN_TAG ERROR_ CLOSE_TAG" },
    { Parser::Nonterminal_::start_tag, 3, "start_tag <- OPEN_TAG ERROR_ END_" },
    { Parser::Nonterminal_::end_tag, 3, "end_tag <- OPEN_END_TAG NAME CLOSE_END_TAG" },
    { Parser::Nonterminal_::end_tag, 4, "end_tag <- OPEN_END_TAG NAME ERROR_ CLOSE_END_TAG" },
    { Parser::Nonterminal_::end_tag, 4, "end_tag <- OPEN_END_TAG NAME ERROR_ END_" },
    { Parser::Nonterminal_::end_tag, 3, "end_tag <- OPEN_END_TAG ERROR_ CLOSE_END_TAG" },
    { Parser::Nonterminal_::end_tag, 3, "end_tag <- OPEN_END_TAG ERROR_ END_" },
    { Parser::Nonterminal_::selfended_tag, 4, "selfended_tag <- OPEN_TAG NAME attribute_list CLOSE_SELFENDED_TAG" },
    { Parser::Nonterminal_::selfended_tag, 4, "selfended_tag <- OPEN_TAG NAME ERROR_ CLOSE_SELFENDED_TAG" },
    { Parser::Nonterminal_::selfended_tag, 3, "selfended_tag <- OPEN_TAG ERROR_ CLOSE_SELFENDED_TAG" },
    { Parser::Nonterminal_::attribute_list, 4, "attribute_list <- attribute_list NAME '=' STRING" },
    { Parser::Nonterminal_::attribute_list, 4, "attribute_list <- attribute_list NAME '=' ERROR_" },
    { Parser::Nonterminal_::attribute_list, 0, "attribute_list <-" }
};
BarfCpp_::Size const Parser::ms_rule_count_ = sizeof(Parser::ms_rule_table_) / sizeof(*Parser::ms_rule_table_);

Parser::State_ const Parser::ms_state_table_[] =
{
    { 3, ms_transition_table_+0, "START document                                \nrule 0: document <- . element_list END_       \nrule 1: element_list <- . element_list element\nrule 2: element_list <- . element_list TEXT   \nrule 3: element_list <- .                     " },
    { 1, ms_transition_table_+3, "RETURN document" },
    { 11, ms_transition_table_+4, "rule 0: document <- element_list . END_                                     \nrule 1: element_list <- element_list . element                              \nrule 4: element <- . processing_instruction                                 \nrule 10: processing_instruction <- . OPEN_PI NAME attribute_list CLOSE_PI   \nrule 11: processing_instruction <- . OPEN_PI NAME ERROR_ CLOSE_PI           \nrule 12: processing_instruction <- . OPEN_PI NAME ERROR_ END_               \nrule 13: processing_instruction <- . OPEN_PI ERROR_ CLOSE_PI                \nrule 14: processing_instruction <- . OPEN_PI ERROR_ END_                    \nrule 5: element <- . start_tag element_list end_tag                         \nrule 15: start_tag <- . OPEN_TAG NAME attribute_list CLOSE_TAG              \nrule 16: start_tag <- . OPEN_TAG NAME ERROR_ CLOSE_TAG                      \nrule 17: start_tag <- . OPEN_TAG NAME ERROR_ END_                           \nrule 18: start_tag <- . OPEN_TAG ERROR_ CLOSE_TAG                           \nrule 19: start_tag <- . OPEN_TAG ERROR_ END_                                \nrule 20: end_tag <- . OPEN_END_TAG NAME CLOSE_END_TAG                       \nrule 21: end_tag <- . OPEN_END_TAG NAME ERROR_ CLOSE_END_TAG                \nrule 22: end_tag <- . OPEN_END_TAG NAME ERROR_ END_                         \nrule 23: end_tag <- . OPEN_END_TAG ERROR_ CLOSE_END_TAG                     \nrule 24: end_tag <- . OPEN_END_TAG ERROR_ END_                              \nrule 6: element <- . start_tag ERROR_ end_tag                               \nrule 7: element <- . start_tag ERROR_ END_                                  \nrule 8: element <- . selfended_tag                                          \nrule 25: selfended_tag <- . OPEN_TAG NAME attribute_list CLOSE_SELFENDED_TAG\nrule 26: selfended_tag <- . OPEN_TAG NAME ERROR_ CLOSE_SELFENDED_TAG        \nrule 27: selfended_tag <- . OPEN_TAG ERROR_ CLOSE_SELFENDED_TAG             \nrule 9: element <- . end_tag                                                \nrule 2: element_list <- element_list . TEXT                                 " },
    { 1, ms_transition_table_+15, "rule 0: document <- element_list END_ ." },
    { 1, ms_transition_table_+16, "rule 2: element_list <- element_list TEXT ." },
    { 3, ms_transition_table_+17, "rule 10: processing_instruction <- OPEN_PI . NAME attribute_list CLOSE_PI\nrule 11: processing_instruction <- OPEN_PI . NAME ERROR_ CLOSE_PI        \nrule 12: processing_instruction <- OPEN_PI . NAME ERROR_ END_            \nrule 13: processing_instruction <- OPEN_PI . ERROR_ CLOSE_PI             \nrule 14: processing_instruction <- OPEN_PI . ERROR_ END_                 " },
    { 3, ms_transition_table_+20, "rule 13: processing_instruction <- OPEN_PI ERROR_ . CLOSE_PI\nrule 14: processing_instruction <- OPEN_PI ERROR_ . END_    " },
    { 1, ms_transition_table_+23, "rule 14: processing_instruction <- OPEN_PI ERROR_ END_ ." },
    { 1, ms_transition_table_+24, "rule 13: processing_instruction <- OPEN_PI ERROR_ CLOSE_PI ." },
    { 3, ms_transition_table_+25, "rule 10: processing_instruction <- OPEN_PI NAME . attribute_list CLOSE_PI\nrule 28: attribute_list <- . attribute_list NAME '=' STRING              \nrule 29: attribute_list <- . attribute_list NAME '=' ERROR_              \nrule 30: attribute_list <- .                                             \nrule 11: processing_instruction <- OPEN_PI NAME . ERROR_ CLOSE_PI        \nrule 12: processing_instruction <- OPEN_PI NAME . ERROR_ END_            " },
    { 3, ms_transition_table_+28, "rule 11: processing_instruction <- OPEN_PI NAME ERROR_ . CLOSE_PI\nrule 12: processing_instruction <- OPEN_PI NAME ERROR_ . END_    " },
    { 1, ms_transition_table_+31, "rule 12: processing_instruction <- OPEN_PI NAME ERROR_ END_ ." },
    { 1, ms_transition_table_+32, "rule 11: processing_instruction <- OPEN_PI NAME ERROR_ CLOSE_PI ." },
    { 3, ms_transition_table_+33, "rule 10: processing_instruction <- OPEN_PI NAME attribute_list . CLOSE_PI\nrule 28: attribute_list <- attribute_list . NAME '=' STRING              \nrule 29: attribute_list <- attribute_list . NAME '=' ERROR_              " },
    { 2, ms_transition_table_+36, "rule 28: attribute_list <- attribute_list NAME . '=' STRING\nrule 29: attribute_list <- attribute_list NAME . '=' ERROR_" },
    { 3, ms_transition_table_+38, "rule 28: attribute_list <- attribute_list NAME '=' . STRING\nrule 29: attribute_list <- attribute_list NAME '=' . ERROR_" },
    { 1, ms_transition_table_+41, "rule 29: attribute_list <- attribute_list NAME '=' ERROR_ ." },
    { 1, ms_transition_table_+42, "rule 28: attribute_list <- attribute_list NAME '=' STRING ." },
    { 1, ms_transition_table_+43, "rule 10: processing_instruction <- OPEN_PI NAME attribute_list CLOSE_PI ." },
    { 3, ms_transition_table_+44, "rule 15: start_tag <- OPEN_TAG . NAME attribute_list CLOSE_TAG              \nrule 16: start_tag <- OPEN_TAG . NAME ERROR_ CLOSE_TAG                      \nrule 17: start_tag <- OPEN_TAG . NAME ERROR_ END_                           \nrule 18: start_tag <- OPEN_TAG . ERROR_ CLOSE_TAG                           \nrule 19: start_tag <- OPEN_TAG . ERROR_ END_                                \nrule 25: selfended_tag <- OPEN_TAG . NAME attribute_list CLOSE_SELFENDED_TAG\nrule 26: selfended_tag <- OPEN_TAG . NAME ERROR_ CLOSE_SELFENDED_TAG        \nrule 27: selfended_tag <- OPEN_TAG . ERROR_ CLOSE_SELFENDED_TAG             " },
    { 4, ms_transition_table_+47, "rule 18: start_tag <- OPEN_TAG ERROR_ . CLOSE_TAG              \nrule 19: start_tag <- OPEN_TAG ERROR_ . END_                   \nrule 27: selfended_tag <- OPEN_TAG ERROR_ . CLOSE_SELFENDED_TAG" },
    { 1, ms_transition_table_+51, "rule 19: start_tag <- OPEN_TAG ERROR_ END_ ." },
    { 1, ms_transition_table_+52, "rule 18: start_tag <- OPEN_TAG ERROR_ CLOSE_TAG ." },
    { 1, ms_transition_table_+53, "rule 27: selfended_tag <- OPEN_TAG ERROR_ CLOSE_SELFENDED_TAG ." },
    { 3, ms_transition_table_+54, "rule 28: attribute_list <- . attribute_list NAME '=' STRING                 \nrule 29: attribute_list <- . attribute_list NAME '=' ERROR_                 \nrule 30: attribute_list <- .                                                \nrule 15: start_tag <- OPEN_TAG NAME . attribute_list CLOSE_TAG              \nrule 16: start_tag <- OPEN_TAG NAME . ERROR_ CLOSE_TAG                      \nrule 17: start_tag <- OPEN_TAG NAME . ERROR_ END_                           \nrule 25: selfended_tag <- OPEN_TAG NAME . attribute_list CLOSE_SELFENDED_TAG\nrule 26: selfended_tag <- OPEN_TAG NAME . ERROR_ CLOSE_SELFENDED_TAG        " },
    { 4, ms_transition_table_+57, "rule 16: start_tag <- OPEN_TAG NAME ERROR_ . CLOSE_TAG              \nrule 17: start_tag <- OPEN_TAG NAME ERROR_ . END_                   \nrule 26: selfended_tag <- OPEN_TAG NAME ERROR_ . CLOSE_SELFENDED_TAG" },
    { 1, ms_transition_table_+61, "rule 17: start_tag <- OPEN_TAG NAME ERROR_ END_ ." },
    { 1, ms_transition_table_+62, "rule 16: start_tag <- OPEN_TAG NAME ERROR_ CLOSE_TAG ." },
    { 1, ms_transition_table_+63, "rule 26: selfended_tag <- OPEN_TAG NAME ERROR_ CLOSE_SELFENDED_TAG ." },
    { 4, ms_transition_table_+64, "rule 28: attribute_list <- attribute_list . NAME '=' STRING                 \nrule 29: attribute_list <- attribute_list . NAME '=' ERROR_                 \nrule 15: start_tag <- OPEN_TAG NAME attribute_list . CLOSE_TAG              \nrule 25: selfended_tag <- OPEN_TAG NAME attribute_list . CLOSE_SELFENDED_TAG" },
    { 1, ms_transition_table_+68, "rule 15: start_tag <- OPEN_TAG NAME attribute_list CLOSE_TAG ." },
    { 1, ms_transition_table_+69, "rule 25: selfended_tag <- OPEN_TAG NAME attribute_list CLOSE_SELFENDED_TAG ." },
    { 3, ms_transition_table_+70, "rule 20: end_tag <- OPEN_END_TAG . NAME CLOSE_END_TAG       \nrule 21: end_tag <- OPEN_END_TAG . NAME ERROR_ CLOSE_END_TAG\nrule 22: end_tag <- OPEN_END_TAG . NAME ERROR_ END_         \nrule 23: end_tag <- OPEN_END_TAG . ERROR_ CLOSE_END_TAG     \nrule 24: end_tag <- OPEN_END_TAG . ERROR_ END_              " },
    { 3, ms_transition_table_+73, "rule 23: end_tag <- OPEN_END_TAG ERROR_ . CLOSE_END_TAG\nrule 24: end_tag <- OPEN_END_TAG ERROR_ . END_         " },
    { 1, ms_transition_table_+76, "rule 24: end_tag <- OPEN_END_TAG ERROR_ END_ ." },
    { 1, ms_transition_table_+77, "rule 23: end_tag <- OPEN_END_TAG ERROR_ CLOSE_END_TAG ." },
    { 3, ms_transition_table_+78, "rule 20: end_tag <- OPEN_END_TAG NAME . CLOSE_END_TAG       \nrule 21: end_tag <- OPEN_END_TAG NAME . ERROR_ CLOSE_END_TAG\nrule 22: end_tag <- OPEN_END_TAG NAME . ERROR_ END_         " },
    { 3, ms_transition_table_+81, "rule 21: end_tag <- OPEN_END_TAG NAME ERROR_ . CLOSE_END_TAG\nrule 22: end_tag <- OPEN_END_TAG NAME ERROR_ . END_         " },
    { 1, ms_transition_table_+84, "rule 22: end_tag <- OPEN_END_TAG NAME ERROR_ END_ ." },
    { 1, ms_transition_table_+85, "rule 21: end_tag <- OPEN_END_TAG NAME ERROR_ CLOSE_END_TAG ." },
    { 1, ms_transition_table_+86, "rule 20: end_tag <- OPEN_END_TAG NAME CLOSE_END_TAG ." },
    { 1, ms_transition_table_+87, "rule 1: element_list <- element_list element ." },
    { 1, ms_transition_table_+88, "rule 4: element <- processing_instruction ." },
    { 3, ms_transition_table_+89, "rule 1: element_list <- . element_list element     \nrule 5: element <- start_tag . element_list end_tag\nrule 6: element <- start_tag . ERROR_ end_tag      \nrule 7: element <- start_tag . ERROR_ END_         \nrule 2: element_list <- . element_list TEXT        \nrule 3: element_list <- .                          " },
    { 4, ms_transition_table_+92, "rule 20: end_tag <- . OPEN_END_TAG NAME CLOSE_END_TAG       \nrule 21: end_tag <- . OPEN_END_TAG NAME ERROR_ CLOSE_END_TAG\nrule 22: end_tag <- . OPEN_END_TAG NAME ERROR_ END_         \nrule 23: end_tag <- . OPEN_END_TAG ERROR_ CLOSE_END_TAG     \nrule 24: end_tag <- . OPEN_END_TAG ERROR_ END_              \nrule 6: element <- start_tag ERROR_ . end_tag               \nrule 7: element <- start_tag ERROR_ . END_                  " },
    { 1, ms_transition_table_+96, "rule 7: element <- start_tag ERROR_ END_ ." },
    { 1, ms_transition_table_+97, "rule 6: element <- start_tag ERROR_ end_tag ." },
    { 10, ms_transition_table_+98, "rule 1: element_list <- element_list . element                              \nrule 4: element <- . processing_instruction                                 \nrule 10: processing_instruction <- . OPEN_PI NAME attribute_list CLOSE_PI   \nrule 11: processing_instruction <- . OPEN_PI NAME ERROR_ CLOSE_PI           \nrule 12: processing_instruction <- . OPEN_PI NAME ERROR_ END_               \nrule 13: processing_instruction <- . OPEN_PI ERROR_ CLOSE_PI                \nrule 14: processing_instruction <- . OPEN_PI ERROR_ END_                    \nrule 5: element <- . start_tag element_list end_tag                         \nrule 15: start_tag <- . OPEN_TAG NAME attribute_list CLOSE_TAG              \nrule 16: start_tag <- . OPEN_TAG NAME ERROR_ CLOSE_TAG                      \nrule 17: start_tag <- . OPEN_TAG NAME ERROR_ END_                           \nrule 18: start_tag <- . OPEN_TAG ERROR_ CLOSE_TAG                           \nrule 19: start_tag <- . OPEN_TAG ERROR_ END_                                \nrule 5: element <- start_tag element_list . end_tag                         \nrule 20: end_tag <- . OPEN_END_TAG NAME CLOSE_END_TAG                       \nrule 21: end_tag <- . OPEN_END_TAG NAME ERROR_ CLOSE_END_TAG                \nrule 22: end_tag <- . OPEN_END_TAG NAME ERROR_ END_                         \nrule 23: end_tag <- . OPEN_END_TAG ERROR_ CLOSE_END_TAG                     \nrule 24: end_tag <- . OPEN_END_TAG ERROR_ END_                              \nrule 6: element <- . start_tag ERROR_ end_tag                               \nrule 7: element <- . start_tag ERROR_ END_                                  \nrule 8: element <- . selfended_tag                                          \nrule 25: selfended_tag <- . OPEN_TAG NAME attribute_list CLOSE_SELFENDED_TAG\nrule 26: selfended_tag <- . OPEN_TAG NAME ERROR_ CLOSE_SELFENDED_TAG        \nrule 27: selfended_tag <- . OPEN_TAG ERROR_ CLOSE_SELFENDED_TAG             \nrule 9: element <- . end_tag                                                \nrule 2: element_list <- element_list . TEXT                                 " },
    { 1, ms_transition_table_+108, "rule 5: element <- start_tag element_list end_tag .\nrule 9: element <- end_tag .                       " },
    { 1, ms_transition_table_+109, "rule 8: element <- selfended_tag ." },
    { 1, ms_transition_table_+110, "rule 9: element <- end_tag ." },
    { 2, ms_transition_table_+111, "START element_list                            \nrule 1: element_list <- . element_list element\nrule 2: element_list <- . element_list TEXT   \nrule 3: element_list <- .                     " },
    { 10, ms_transition_table_+113, "RETURN element_list                                                         \nrule 1: element_list <- element_list . element                              \nrule 4: element <- . processing_instruction                                 \nrule 10: processing_instruction <- . OPEN_PI NAME attribute_list CLOSE_PI   \nrule 11: processing_instruction <- . OPEN_PI NAME ERROR_ CLOSE_PI           \nrule 12: processing_instruction <- . OPEN_PI NAME ERROR_ END_               \nrule 13: processing_instruction <- . OPEN_PI ERROR_ CLOSE_PI                \nrule 14: processing_instruction <- . OPEN_PI ERROR_ END_                    \nrule 5: element <- . start_tag element_list end_tag                         \nrule 15: start_tag <- . OPEN_TAG NAME attribute_list CLOSE_TAG              \nrule 16: start_tag <- . OPEN_TAG NAME ERROR_ CLOSE_TAG                      \nrule 17: start_tag <- . OPEN_TAG NAME ERROR_ END_                           \nrule 18: start_tag <- . OPEN_TAG ERROR_ CLOSE_TAG                           \nrule 19: start_tag <- . OPEN_TAG ERROR_ END_                                \nrule 20: end_tag <- . OPEN_END_TAG NAME CLOSE_END_TAG                       \nrule 21: end_tag <- . OPEN_END_TAG NAME ERROR_ CLOSE_END_TAG                \nrule 22: end_tag <- . OPEN_END_TAG NAME ERROR_ END_                         \nrule 23: end_tag <- . OPEN_END_TAG ERROR_ CLOSE_END_TAG                     \nrule 24: end_tag <- . OPEN_END_TAG ERROR_ END_                              \nrule 6: element <- . start_tag ERROR_ end_tag                               \nrule 7: element <- . start_tag ERROR_ END_                                  \nrule 8: element <- . selfended_tag                                          \nrule 25: selfended_tag <- . OPEN_TAG NAME attribute_list CLOSE_SELFENDED_TAG\nrule 26: selfended_tag <- . OPEN_TAG NAME ERROR_ CLOSE_SELFENDED_TAG        \nrule 27: selfended_tag <- . OPEN_TAG ERROR_ CLOSE_SELFENDED_TAG             \nrule 9: element <- . end_tag                                                \nrule 2: element_list <- element_list . TEXT                                 " },
    { 9, ms_transition_table_+123, "START element                                                               \nrule 4: element <- . processing_instruction                                 \nrule 10: processing_instruction <- . OPEN_PI NAME attribute_list CLOSE_PI   \nrule 11: processing_instruction <- . OPEN_PI NAME ERROR_ CLOSE_PI           \nrule 12: processing_instruction <- . OPEN_PI NAME ERROR_ END_               \nrule 13: processing_instruction <- . OPEN_PI ERROR_ CLOSE_PI                \nrule 14: processing_instruction <- . OPEN_PI ERROR_ END_                    \nrule 5: element <- . start_tag element_list end_tag                         \nrule 15: start_tag <- . OPEN_TAG NAME attribute_list CLOSE_TAG              \nrule 16: start_tag <- . OPEN_TAG NAME ERROR_ CLOSE_TAG                      \nrule 17: start_tag <- . OPEN_TAG NAME ERROR_ END_                           \nrule 18: start_tag <- . OPEN_TAG ERROR_ CLOSE_TAG                           \nrule 19: start_tag <- . OPEN_TAG ERROR_ END_                                \nrule 20: end_tag <- . OPEN_END_TAG NAME CLOSE_END_TAG                       \nrule 21: end_tag <- . OPEN_END_TAG NAME ERROR_ CLOSE_END_TAG                \nrule 22: end_tag <- . OPEN_END_TAG NAME ERROR_ END_                         \nrule 23: end_tag <- . OPEN_END_TAG ERROR_ CLOSE_END_TAG                     \nrule 24: end_tag <- . OPEN_END_TAG ERROR_ END_                              \nrule 6: element <- . start_tag ERROR_ end_tag                               \nrule 7: element <- . start_tag ERROR_ END_                                  \nrule 8: element <- . selfended_tag                                          \nrule 25: selfended_tag <- . OPEN_TAG NAME attribute_list CLOSE_SELFENDED_TAG\nrule 26: selfended_tag <- . OPEN_TAG NAME ERROR_ CLOSE_SELFENDED_TAG        \nrule 27: selfended_tag <- . OPEN_TAG ERROR_ CLOSE_SELFENDED_TAG             \nrule 9: element <- . end_tag                                                " },
    { 1, ms_transition_table_+132, "RETURN element" },
    { 3, ms_transition_table_+133, "START processing_instruction                                             \nrule 10: processing_instruction <- . OPEN_PI NAME attribute_list CLOSE_PI\nrule 11: processing_instruction <- . OPEN_PI NAME ERROR_ CLOSE_PI        \nrule 12: processing_instruction <- . OPEN_PI NAME ERROR_ END_            \nrule 13: processing_instruction <- . OPEN_PI ERROR_ CLOSE_PI             \nrule 14: processing_instruction <- . OPEN_PI ERROR_ END_                 " },
    { 1, ms_transition_table_+136, "RETURN processing_instruction" },
    { 3, ms_transition_table_+137, "START start_tag                                               \nrule 15: start_tag <- . OPEN_TAG NAME attribute_list CLOSE_TAG\nrule 16: start_tag <- . OPEN_TAG NAME ERROR_ CLOSE_TAG        \nrule 17: start_tag <- . OPEN_TAG NAME ERROR_ END_             \nrule 18: start_tag <- . OPEN_TAG ERROR_ CLOSE_TAG             \nrule 19: start_tag <- . OPEN_TAG ERROR_ END_                  " },
    { 3, ms_transition_table_+140, "rule 15: start_tag <- OPEN_TAG . NAME attribute_list CLOSE_TAG\nrule 16: start_tag <- OPEN_TAG . NAME ERROR_ CLOSE_TAG        \nrule 17: start_tag <- OPEN_TAG . NAME ERROR_ END_             \nrule 18: start_tag <- OPEN_TAG . ERROR_ CLOSE_TAG             \nrule 19: start_tag <- OPEN_TAG . ERROR_ END_                  " },
    { 3, ms_transition_table_+143, "rule 18: start_tag <- OPEN_TAG ERROR_ . CLOSE_TAG\nrule 19: start_tag <- OPEN_TAG ERROR_ . END_     " },
    { 3, ms_transition_table_+146, "rule 28: attribute_list <- . attribute_list NAME '=' STRING   \nrule 29: attribute_list <- . attribute_list NAME '=' ERROR_   \nrule 30: attribute_list <- .                                  \nrule 15: start_tag <- OPEN_TAG NAME . attribute_list CLOSE_TAG\nrule 16: start_tag <- OPEN_TAG NAME . ERROR_ CLOSE_TAG        \nrule 17: start_tag <- OPEN_TAG NAME . ERROR_ END_             " },
    { 3, ms_transition_table_+149, "rule 16: start_tag <- OPEN_TAG NAME ERROR_ . CLOSE_TAG\nrule 17: start_tag <- OPEN_TAG NAME ERROR_ . END_     " },
    { 3, ms_transition_table_+152, "rule 28: attribute_list <- attribute_list . NAME '=' STRING   \nrule 29: attribute_list <- attribute_list . NAME '=' ERROR_   \nrule 15: start_tag <- OPEN_TAG NAME attribute_list . CLOSE_TAG" },
    { 1, ms_transition_table_+155, "RETURN start_tag" },
    { 3, ms_transition_table_+156, "START end_tag                                               \nrule 20: end_tag <- . OPEN_END_TAG NAME CLOSE_END_TAG       \nrule 21: end_tag <- . OPEN_END_TAG NAME ERROR_ CLOSE_END_TAG\nrule 22: end_tag <- . OPEN_END_TAG NAME ERROR_ END_         \nrule 23: end_tag <- . OPEN_END_TAG ERROR_ CLOSE_END_TAG     \nrule 24: end_tag <- . OPEN_END_TAG ERROR_ END_              " },
    { 1, ms_transition_table_+159, "RETURN end_tag" },
    { 3, ms_transition_table_+160, "START selfended_tag                                                         \nrule 25: selfended_tag <- . OPEN_TAG NAME attribute_list CLOSE_SELFENDED_TAG\nrule 26: selfended_tag <- . OPEN_TAG NAME ERROR_ CLOSE_SELFENDED_TAG        \nrule 27: selfended_tag <- . OPEN_TAG ERROR_ CLOSE_SELFENDED_TAG             " },
    { 3, ms_transition_table_+163, "rule 25: selfended_tag <- OPEN_TAG . NAME attribute_list CLOSE_SELFENDED_TAG\nrule 26: selfended_tag <- OPEN_TAG . NAME ERROR_ CLOSE_SELFENDED_TAG        \nrule 27: selfended_tag <- OPEN_TAG . ERROR_ CLOSE_SELFENDED_TAG             " },
    { 2, ms_transition_table_+166, "rule 27: selfended_tag <- OPEN_TAG ERROR_ . CLOSE_SELFENDED_TAG" },
    { 3, ms_transition_table_+168, "rule 28: attribute_list <- . attribute_list NAME '=' STRING                 \nrule 29: attribute_list <- . attribute_list NAME '=' ERROR_                 \nrule 30: attribute_list <- .                                                \nrule 25: selfended_tag <- OPEN_TAG NAME . attribute_list CLOSE_SELFENDED_TAG\nrule 26: selfended_tag <- OPEN_TAG NAME . ERROR_ CLOSE_SELFENDED_TAG        " },
    { 2, ms_transition_table_+171, "rule 26: selfended_tag <- OPEN_TAG NAME ERROR_ . CLOSE_SELFENDED_TAG" },
    { 3, ms_transition_table_+173, "rule 28: attribute_list <- attribute_list . NAME '=' STRING                 \nrule 29: attribute_list <- attribute_list . NAME '=' ERROR_                 \nrule 25: selfended_tag <- OPEN_TAG NAME attribute_list . CLOSE_SELFENDED_TAG" },
    { 1, ms_transition_table_+176, "RETURN selfended_tag" },
    { 2, ms_transition_table_+177, "START attribute_list                                       \nrule 28: attribute_list <- . attribute_list NAME '=' STRING\nrule 29: attribute_list <- . attribute_list NAME '=' ERROR_\nrule 30: attribute_list <- .                               " },
    { 2, ms_transition_table_+179, "RETURN attribute_list                                      \nrule 28: attribute_list <- attribute_list . NAME '=' STRING\nrule 29: attribute_list <- attribute_list . NAME '=' ERROR_" }
};
BarfCpp_::Size const Parser::ms_state_count_ = sizeof(Parser::ms_state_table_) / sizeof(*Parser::ms_state_table_);

Parser::Transition_ const Parser::ms_transition_table_[] =
{
    { Parser::Transition_::REDUCE, 3, 0, ms_lookahead_table_+0 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+0 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+1 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+2 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+2 },
    { Parser::Transition_::SHIFT, 3, 1, ms_lookahead_table_+2 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+3 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+4 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+5 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+6 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+7 },
    { Parser::Transition_::SHIFT, 42, 1, ms_lookahead_table_+8 },
    { Parser::Transition_::SHIFT, 43, 1, ms_lookahead_table_+9 },
    { Parser::Transition_::SHIFT, 50, 1, ms_lookahead_table_+10 },
    { Parser::Transition_::SHIFT, 49, 1, ms_lookahead_table_+11 },
    { Parser::Transition_::REDUCE, 0, 0, ms_lookahead_table_+12 },
    { Parser::Transition_::REDUCE, 2, 0, ms_lookahead_table_+12 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+12 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+12 },
    { Parser::Transition_::SHIFT, 9, 1, ms_lookahead_table_+13 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+14 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+14 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+15 },
    { Parser::Transition_::REDUCE, 14, 0, ms_lookahead_table_+16 },
    { Parser::Transition_::REDUCE, 13, 0, ms_lookahead_table_+16 },
    { Parser::Transition_::REDUCE, 30, 0, ms_lookahead_table_+16 },
    { Parser::Transition_::SHIFT, 10, 1, ms_lookahead_table_+16 },
    { Parser::Transition_::SHIFT, 13, 1, ms_lookahead_table_+17 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+18 },
    { Parser::Transition_::SHIFT, 11, 1, ms_lookahead_table_+18 },
    { Parser::Transition_::SHIFT, 12, 1, ms_lookahead_table_+19 },
    { Parser::Transition_::REDUCE, 12, 0, ms_lookahead_table_+20 },
    { Parser::Transition_::REDUCE, 11, 0, ms_lookahead_table_+20 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+20 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+20 },
    { Parser::Transition_::SHIFT, 18, 1, ms_lookahead_table_+21 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+22 },
    { Parser::Transition_::SHIFT, 15, 1, ms_lookahead_table_+22 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+23 },
    { Parser::Transition_::SHIFT, 16, 1, ms_lookahead_table_+23 },
    { Parser::Transition_::SHIFT, 17, 1, ms_lookahead_table_+24 },
    { Parser::Transition_::REDUCE, 29, 0, ms_lookahead_table_+25 },
    { Parser::Transition_::REDUCE, 28, 0, ms_lookahead_table_+25 },
    { Parser::Transition_::REDUCE, 10, 0, ms_lookahead_table_+25 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+25 },
    { Parser::Transition_::SHIFT, 20, 1, ms_lookahead_table_+25 },
    { Parser::Transition_::SHIFT, 24, 1, ms_lookahead_table_+26 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+27 },
    { Parser::Transition_::SHIFT, 21, 1, ms_lookahead_table_+27 },
    { Parser::Transition_::SHIFT, 22, 1, ms_lookahead_table_+28 },
    { Parser::Transition_::SHIFT, 23, 1, ms_lookahead_table_+29 },
    { Parser::Transition_::REDUCE, 19, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::REDUCE, 18, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::REDUCE, 27, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::REDUCE, 30, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::SHIFT, 25, 1, ms_lookahead_table_+30 },
    { Parser::Transition_::SHIFT, 29, 1, ms_lookahead_table_+31 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+32 },
    { Parser::Transition_::SHIFT, 26, 1, ms_lookahead_table_+32 },
    { Parser::Transition_::SHIFT, 27, 1, ms_lookahead_table_+33 },
    { Parser::Transition_::SHIFT, 28, 1, ms_lookahead_table_+34 },
    { Parser::Transition_::REDUCE, 17, 0, ms_lookahead_table_+35 },
    { Parser::Transition_::REDUCE, 16, 0, ms_lookahead_table_+35 },
    { Parser::Transition_::REDUCE, 26, 0, ms_lookahead_table_+35 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+35 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+35 },
    { Parser::Transition_::SHIFT, 30, 1, ms_lookahead_table_+36 },
    { Parser::Transition_::SHIFT, 31, 1, ms_lookahead_table_+37 },
    { Parser::Transition_::REDUCE, 15, 0, ms_lookahead_table_+38 },
    { Parser::Transition_::REDUCE, 25, 0, ms_lookahead_table_+38 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+38 },
    { Parser::Transition_::SHIFT, 33, 1, ms_lookahead_table_+38 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+39 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+40 },
    { Parser::Transition_::SHIFT, 34, 1, ms_lookahead_table_+40 },
    { Parser::Transition_::SHIFT, 35, 1, ms_lookahead_table_+41 },
    { Parser::Transition_::REDUCE, 24, 0, ms_lookahead_table_+42 },
    { Parser::Transition_::REDUCE, 23, 0, ms_lookahead_table_+42 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+42 },
    { Parser::Transition_::SHIFT, 37, 1, ms_lookahead_table_+42 },
    { Parser::Transition_::SHIFT, 40, 1, ms_lookahead_table_+43 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+44 },
    { Parser::Transition_::SHIFT, 38, 1, ms_lookahead_table_+44 },
    { Parser::Transition_::SHIFT, 39, 1, ms_lookahead_table_+45 },
    { Parser::Transition_::REDUCE, 22, 0, ms_lookahead_table_+46 },
    { Parser::Transition_::REDUCE, 21, 0, ms_lookahead_table_+46 },
    { Parser::Transition_::REDUCE, 20, 0, ms_lookahead_table_+46 },
    { Parser::Transition_::REDUCE, 1, 0, ms_lookahead_table_+46 },
    { Parser::Transition_::REDUCE, 4, 0, ms_lookahead_table_+46 },
    { Parser::Transition_::REDUCE, 3, 0, ms_lookahead_table_+46 },
    { Parser::Transition_::SHIFT, 44, 1, ms_lookahead_table_+46 },
    { Parser::Transition_::SHIFT, 47, 1, ms_lookahead_table_+47 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+48 },
    { Parser::Transition_::SHIFT, 45, 1, ms_lookahead_table_+48 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+49 },
    { Parser::Transition_::SHIFT, 46, 1, ms_lookahead_table_+50 },
    { Parser::Transition_::REDUCE, 7, 0, ms_lookahead_table_+51 },
    { Parser::Transition_::REDUCE, 6, 0, ms_lookahead_table_+51 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+51 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+51 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+52 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+53 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+54 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+55 },
    { Parser::Transition_::SHIFT, 42, 1, ms_lookahead_table_+56 },
    { Parser::Transition_::SHIFT, 43, 1, ms_lookahead_table_+57 },
    { Parser::Transition_::SHIFT, 48, 1, ms_lookahead_table_+58 },
    { Parser::Transition_::SHIFT, 49, 1, ms_lookahead_table_+59 },
    { Parser::Transition_::REDUCE, 5, 0, ms_lookahead_table_+60 },
    { Parser::Transition_::REDUCE, 8, 0, ms_lookahead_table_+60 },
    { Parser::Transition_::REDUCE, 9, 0, ms_lookahead_table_+60 },
    { Parser::Transition_::REDUCE, 3, 0, ms_lookahead_table_+60 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+60 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+61 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+61 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+62 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+63 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+64 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+65 },
    { Parser::Transition_::SHIFT, 42, 1, ms_lookahead_table_+66 },
    { Parser::Transition_::SHIFT, 43, 1, ms_lookahead_table_+67 },
    { Parser::Transition_::SHIFT, 50, 1, ms_lookahead_table_+68 },
    { Parser::Transition_::SHIFT, 49, 1, ms_lookahead_table_+69 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+70 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+70 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+71 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+72 },
    { Parser::Transition_::SHIFT, 54, 1, ms_lookahead_table_+73 },
    { Parser::Transition_::SHIFT, 42, 1, ms_lookahead_table_+74 },
    { Parser::Transition_::SHIFT, 43, 1, ms_lookahead_table_+75 },
    { Parser::Transition_::SHIFT, 50, 1, ms_lookahead_table_+76 },
    { Parser::Transition_::SHIFT, 49, 1, ms_lookahead_table_+77 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+78 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+78 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+78 },
    { Parser::Transition_::SHIFT, 56, 1, ms_lookahead_table_+79 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+80 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+80 },
    { Parser::Transition_::SHIFT, 58, 1, ms_lookahead_table_+80 },
    { Parser::Transition_::SHIFT, 63, 1, ms_lookahead_table_+81 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+82 },
    { Parser::Transition_::SHIFT, 59, 1, ms_lookahead_table_+82 },
    { Parser::Transition_::SHIFT, 60, 1, ms_lookahead_table_+83 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+84 },
    { Parser::Transition_::SHIFT, 21, 1, ms_lookahead_table_+84 },
    { Parser::Transition_::SHIFT, 22, 1, ms_lookahead_table_+85 },
    { Parser::Transition_::REDUCE, 30, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::SHIFT, 61, 1, ms_lookahead_table_+86 },
    { Parser::Transition_::SHIFT, 62, 1, ms_lookahead_table_+87 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+88 },
    { Parser::Transition_::SHIFT, 26, 1, ms_lookahead_table_+88 },
    { Parser::Transition_::SHIFT, 27, 1, ms_lookahead_table_+89 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+90 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+90 },
    { Parser::Transition_::SHIFT, 30, 1, ms_lookahead_table_+91 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+92 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+92 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+92 },
    { Parser::Transition_::SHIFT, 65, 1, ms_lookahead_table_+93 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+94 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+94 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+94 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+95 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+96 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+96 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+97 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+98 },
    { Parser::Transition_::SHIFT, 23, 1, ms_lookahead_table_+98 },
    { Parser::Transition_::REDUCE, 30, 0, ms_lookahead_table_+99 },
    { Parser::Transition_::SHIFT, 70, 1, ms_lookahead_table_+99 },
    { Parser::Transition_::SHIFT, 71, 1, ms_lookahead_table_+100 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+101 },
    { Parser::Transition_::SHIFT, 28, 1, ms_lookahead_table_+101 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+102 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+102 },
    { Parser::Transition_::SHIFT, 31, 1, ms_lookahead_table_+103 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+104 },
    { Parser::Transition_::REDUCE, 30, 0, ms_lookahead_table_+104 },
    { Parser::Transition_::SHIFT, 74, 1, ms_lookahead_table_+104 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+105 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+105 }
};
BarfCpp_::Size const Parser::ms_transition_count_ = sizeof(Parser::ms_transition_table_) / sizeof(*Parser::ms_transition_table_);

Parser::Token::Id const Parser::ms_lookahead_table_[] =
{
    Parser::Nonterminal_::document,
    Parser::Nonterminal_::element_list,
    Parser::Terminal::END_,
    Parser::Terminal::TEXT,
    Parser::Terminal::OPEN_PI,
    Parser::Terminal::OPEN_TAG,
    Parser::Terminal::OPEN_END_TAG,
    Parser::Nonterminal_::element,
    Parser::Nonterminal_::processing_instruction,
    Parser::Nonterminal_::start_tag,
    Parser::Nonterminal_::end_tag,
    Parser::Nonterminal_::selfended_tag,
    Parser::Terminal::ERROR_,
    Parser::Terminal::NAME,
    Parser::Terminal::END_,
    Parser::Terminal::CLOSE_PI,
    Parser::Terminal::ERROR_,
    Parser::Nonterminal_::attribute_list,
    Parser::Terminal::END_,
    Parser::Terminal::CLOSE_PI,
    Parser::Terminal::NAME,
    Parser::Terminal::CLOSE_PI,
    '=',
    Parser::Terminal::ERROR_,
    Parser::Terminal::STRING,
    Parser::Terminal::ERROR_,
    Parser::Terminal::NAME,
    Parser::Terminal::END_,
    Parser::Terminal::CLOSE_TAG,
    Parser::Terminal::CLOSE_SELFENDED_TAG,
    Parser::Terminal::ERROR_,
    Parser::Nonterminal_::attribute_list,
    Parser::Terminal::END_,
    Parser::Terminal::CLOSE_TAG,
    Parser::Terminal::CLOSE_SELFENDED_TAG,
    Parser::Terminal::NAME,
    Parser::Terminal::CLOSE_TAG,
    Parser::Terminal::CLOSE_SELFENDED_TAG,
    Parser::Terminal::ERROR_,
    Parser::Terminal::NAME,
    Parser::Terminal::END_,
    Parser::Terminal::CLOSE_END_TAG,
    Parser::Terminal::ERROR_,
    Parser::Terminal::CLOSE_END_TAG,
    Parser::Terminal::END_,
    Parser::Terminal::CLOSE_END_TAG,
    Parser::Terminal::ERROR_,
    Parser::Nonterminal_::element_list,
    Parser::Terminal::END_,
    Parser::Terminal::OPEN_END_TAG,
    Parser::Nonterminal_::end_tag,
    Parser::Terminal::TEXT,
    Parser::Terminal::OPEN_PI,
    Parser::Terminal::OPEN_TAG,
    Parser::Terminal::OPEN_END_TAG,
    Parser::Nonterminal_::element,
    Parser::Nonterminal_::processing_instruction,
    Parser::Nonterminal_::start_tag,
    Parser::Nonterminal_::end_tag,
    Parser::Nonterminal_::selfended_tag,
    Parser::Nonterminal_::element_list,
    Parser::Terminal::TEXT,
    Parser::Terminal::OPEN_PI,
    Parser::Terminal::OPEN_TAG,
    Parser::Terminal::OPEN_END_TAG,
    Parser::Nonterminal_::element,
    Parser::Nonterminal_::processing_instruction,
    Parser::Nonterminal_::start_tag,
    Parser::Nonterminal_::end_tag,
    Parser::Nonterminal_::selfended_tag,
    Parser::Terminal::OPEN_PI,
    Parser::Terminal::OPEN_TAG,
    Parser::Terminal::OPEN_END_TAG,
    Parser::Nonterminal_::element,
    Parser::Nonterminal_::processing_instruction,
    Parser::Nonterminal_::start_tag,
    Parser::Nonterminal_::end_tag,
    Parser::Nonterminal_::selfended_tag,
    Parser::Terminal::OPEN_PI,
    Parser::Nonterminal_::processing_instruction,
    Parser::Terminal::OPEN_TAG,
    Parser::Nonterminal_::start_tag,
    Parser::Terminal::ERROR_,
    Parser::Terminal::NAME,
    Parser::Terminal::END_,
    Parser::Terminal::CLOSE_TAG,
    Parser::Terminal::ERROR_,
    Parser::Nonterminal_::attribute_list,
    Parser::Terminal::END_,
    Parser::Terminal::CLOSE_TAG,
    Parser::Terminal::NAME,
    Parser::Terminal::CLOSE_TAG,
    Parser::Terminal::OPEN_END_TAG,
    Parser::Nonterminal_::end_tag,
    Parser::Terminal::OPEN_TAG,
    Parser::Nonterminal_::selfended_tag,
    Parser::Terminal::ERROR_,
    Parser::Terminal::NAME,
    Parser::Terminal::CLOSE_SELFENDED_TAG,
    Parser::Terminal::ERROR_,
    Parser::Nonterminal_::attribute_list,
    Parser::Terminal::CLOSE_SELFENDED_TAG,
    Parser::Terminal::NAME,
    Parser::Terminal::CLOSE_SELFENDED_TAG,
    Parser::Nonterminal_::attribute_list,
    Parser::Terminal::NAME
};
BarfCpp_::Size const Parser::ms_lookahead_count_ = sizeof(Parser::ms_lookahead_table_) / sizeof(*Parser::ms_lookahead_table_);

char const *const Parser::ms_token_name_table_[] =
{
    "'\\0'",
    "'\\x01'",
    "'\\x02'",
    "'\\x03'",
    "'\\x04'",
    "'\\x05'",
    "'\\x06'",
    "'\\a'",
    "'\\b'",
    "'\\t'",
    "'\\n'",
    "'\\v'",
    "'\\f'",
    "'\\r'",
    "'\\x0E'",
    "'\\x0F'",
    "'\\x10'",
    "'\\x11'",
    "'\\x12'",
    "'\\x13'",
    "'\\x14'",
    "'\\x15'",
    "'\\x16'",
    "'\\x17'",
    "'\\x18'",
    "'\\x19'",
    "'\\x1A'",
    "'\\x1B'",
    "'\\x1C'",
    "'\\x1D'",
    "'\\x1E'",
    "'\\x1F'",
    "' '",
    "'!'",
    "'\"'",
    "'#'",
    "'$'",
    "'%'",
    "'&'",
    "'\\''",
    "'('",
    "')'",
    "'*'",
    "'+'",
    "','",
    "'-'",
    "'.'",
    "'/'",
    "'0'",
    "'1'",
    "'2'",
    "'3'",
    "'4'",
    "'5'",
    "'6'",
    "'7'",
    "'8'",
    "'9'",
    "':'",
    "';'",
    "'<'",
    "'='",
    "'>'",
    "'?'",
    "'@'",
    "'A'",
    "'B'",
    "'C'",
    "'D'",
    "'E'",
    "'F'",
    "'G'",
    "'H'",
    "'I'",
    "'J'",
    "'K'",
    "'L'",
    "'M'",
    "'N'",
    "'O'",
    "'P'",
    "'Q'",
    "'R'",
    "'S'",
    "'T'",
    "'U'",
    "'V'",
    "'W'",
    "'X'",
    "'Y'",
    "'Z'",
    "'['",
    "'\\\\'",
    "']'",
    "'^'",
    "'_'",
    "'`'",
    "'a'",
    "'b'",
    "'c'",
    "'d'",
    "'e'",
    "'f'",
    "'g'",
    "'h'",
    "'i'",
    "'j'",
    "'k'",
    "'l'",
    "'m'",
    "'n'",
    "'o'",
    "'p'",
    "'q'",
    "'r'",
    "'s'",
    "'t'",
    "'u'",
    "'v'",
    "'w'",
    "'x'",
    "'y'",
    "'z'",
    "'{'",
    "'|'",
    "'}'",
    "'~'",
    "'\\x7F'",
    "'\\x80'",
    "'\\x81'",
    "'\\x82'",
    "'\\x83'",
    "'\\x84'",
    "'\\x85'",
    "'\\x86'",
    "'\\x87'",
    "'\\x88'",
    "'\\x89'",
    "'\\x8A'",
    "'\\x8B'",
    "'\\x8C'",
    "'\\x8D'",
    "'\\x8E'",
    "'\\x8F'",
    "'\\x90'",
    "'\\x91'",
    "'\\x92'",
    "'\\x93'",
    "'\\x94'",
    "'\\x95'",
    "'\\x96'",
    "'\\x97'",
    "'\\x98'",
    "'\\x99'",
    "'\\x9A'",
    "'\\x9B'",
    "'\\x9C'",
    "'\\x9D'",
    "'\\x9E'",
    "'\\x9F'",
    "'\\xA0'",
    "'\\xA1'",
    "'\\xA2'",
    "'\\xA3'",
    "'\\xA4'",
    "'\\xA5'",
    "'\\xA6'",
    "'\\xA7'",
    "'\\xA8'",
    "'\\xA9'",
    "'\\xAA'",
    "'\\xAB'",
    "'\\xAC'",
    "'\\xAD'",
    "'\\xAE'",
    "'\\xAF'",
    "'\\xB0'",
    "'\\xB1'",
    "'\\xB2'",
    "'\\xB3'",
    "'\\xB4'",
    "'\\xB5'",
    "'\\xB6'",
    "'\\xB7'",
    "'\\xB8'",
    "'\\xB9'",
    "'\\xBA'",
    "'\\xBB'",
    "'\\xBC'",
    "'\\xBD'",
    "'\\xBE'",
    "'\\xBF'",
    "'\\xC0'",
    "'\\xC1'",
    "'\\xC2'",
    "'\\xC3'",
    "'\\xC4'",
    "'\\xC5'",
    "'\\xC6'",
    "'\\xC7'",
    "'\\xC8'",
    "'\\xC9'",
    "'\\xCA'",
    "'\\xCB'",
    "'\\xCC'",
    "'\\xCD'",
    "'\\xCE'",
    "'\\xCF'",
    "'\\xD0'",
    "'\\xD1'",
    "'\\xD2'",
    "'\\xD3'",
    "'\\xD4'",
    "'\\xD5'",
    "'\\xD6'",
    "'\\xD7'",
    "'\\xD8'",
    "'\\xD9'",
    "'\\xDA'",
    "'\\xDB'",
    "'\\xDC'",
    "'\\xDD'",
    "'\\xDE'",
    "'\\xDF'",
    "'\\xE0'",
    "'\\xE1'",
    "'\\xE2'",
    "'\\xE3'",
    "'\\xE4'",
    "'\\xE5'",
    "'\\xE6'",
    "'\\xE7'",
    "'\\xE8'",
    "'\\xE9'",
    "'\\xEA'",
    "'\\xEB'",
    "'\\xEC'",
    "'\\xED'",
    "'\\xEE'",
    "'\\xEF'",
    "'\\xF0'",
    "'\\xF1'",
    "'\\xF2'",
    "'\\xF3'",
    "'\\xF4'",
    "'\\xF5'",
    "'\\xF6'",
    "'\\xF7'",
    "'\\xF8'",
    "'\\xF9'",
    "'\\xFA'",
    "'\\xFB'",
    "'\\xFC'",
    "'\\xFD'",
    "'\\xFE'",
    "'\\xFF'",
    "END_",
    "ERROR_",
    "BAD_TOKEN",
    "NAME",
    "STRING",
    "TEXT",
    "OPEN_PI",
    "OPEN_TAG",
    "OPEN_END_TAG",
    "CLOSE_PI",
    "CLOSE_TAG",
    "CLOSE_END_TAG",
    "CLOSE_SELFENDED_TAG",
    "document",
    "element_list",
    "element",
    "processing_instruction",
    "start_tag",
    "end_tag",
    "selfended_tag",
    "attribute_list"
};
BarfCpp_::Size const Parser::ms_token_name_count_ = sizeof(Parser::ms_token_name_table_) / sizeof(*Parser::ms_token_name_table_);

// ///////////////////////////////////////////////////////////////////////
// end of internal trison-generated parser guts
// ///////////////////////////////////////////////////////////////////////


#line 98 "lvd_xml_parser.trison"

bool Parser::IsOpen () const
{
    return m_scanner.IsOpen();
}

FiLoc const &Parser::GetFiLoc () const
{
    return m_scanner.GetFiLoc();
}

bool Parser::WarningsWereEncountered () const
{
    return m_scanner.WarningsWereEncountered();
}

bool Parser::ErrorsWereEncountered () const
{
    return m_scanner.ErrorsWereEncountered();
}

bool Parser::ChopLeadingAndTrailingTextWhitespace () const
{
    return m_scanner.ChopLeadingAndTrailingTextWhitespace();
}

void Parser::ChopLeadingAndTrailingTextWhitespace (bool chop)
{
    m_scanner.ChopLeadingAndTrailingTextWhitespace(chop);
}

ostream *Parser::WarningAndErrorLogStream () const
{
    return m_scanner.WarningAndErrorLogStream();
}

void Parser::WarningAndErrorLogStream (ostream *log_stream)
{
    m_scanner.WarningAndErrorLogStream(log_stream);
}

bool Parser::ScannerDebugSpew () const
{
    return m_scanner.DebugSpew();
}

void Parser::ScannerDebugSpew (bool debug_spew)
{
    m_scanner.DebugSpew(debug_spew);
}

bool Parser::OpenFile (string const &input_filename)
{
    Close();
    return m_scanner.OpenFile(input_filename);
}

void Parser::OpenString (string const &input_string, string const &input_name, bool use_line_numbers)
{
    Close();
    m_scanner.OpenString(input_string, input_name, use_line_numbers);
}

void Parser::OpenUsingStream (istream *input_stream, string const &input_name, bool use_line_numbers)
{
    Close();
    m_scanner.OpenUsingStream(input_stream, input_name, use_line_numbers);
}

bool Parser::Close ()
{
    ResetForNewInput();
    return m_scanner.Close();
}

void Parser::EmitWarning (std::string const &message, FiLoc const &filoc)
{
    m_scanner.EmitWarning(message, filoc);
}

void Parser::EmitError (std::string const &message, FiLoc const &filoc)
{
    m_scanner.EmitError(message, filoc);
}

} // end of namespace Xml
} // end of namespace Lvd

#line 1882 "lvd_xml_parser.cpp"
