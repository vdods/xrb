// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// xrb_parse_datafile_scanner.cpp generated by reflex
// from xrb_parse_datafile_scanner.reflex using reflex.cpp.targetspec and reflex.cpp.implementation.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "xrb_parse_datafile_scanner.hpp"

#include <iostream>

#define REFLEX_CPP_DEBUG_CODE_(spew_code) if (DebugSpew()) { spew_code; }


#line 71 "xrb_parse_datafile_scanner.reflex"

#include <errno.h>
#include <stdlib.h>

#include "xrb_emptystring.hpp"
#include "xrb_parse_datafile_value.hpp"
#include "xrb_parse_util.hpp"

namespace Xrb {
namespace Parse {
namespace DataFile {

bool Scanner::Open (std::string const &input_path)
{
    ASSERT1(!m_input.is_open() && "you must call Close() first");
    ASSERT1(!m_filoc.IsValid());
    ASSERT1(m_string_literal == NULL);

    m_input.open(input_path.c_str());
    m_input.unsetf(std::ios_base::skipws);
    if (m_input.is_open())
    {
        IstreamIterator(std::istream_iterator<char>(m_input));
        m_filoc.SetFilename(input_path);
        m_filoc.SetLineNumber(1);
    }
    else
    {
        m_filoc = FiLoc::ms_invalid;
    }
    m_warnings_were_encountered = false;
    m_errors_were_encountered = false;
    return m_input.is_open();
}

void Scanner::Close ()
{
    m_filoc = FiLoc::ms_invalid;
    if (m_input.is_open())
    {
        m_input.close();
        IstreamIterator(std::istream_iterator<char>());
    }
    ResetForNewInput();
}

void Scanner::EmitWarning (std::string const &message, FiLoc const &filoc)
{
    ASSERT1(m_filoc.IsValid());
    ASSERT1(m_input.is_open());
    std::cerr << filoc << ": warning: " << message << std::endl;
    m_warnings_were_encountered = true;
}

void Scanner::EmitError (std::string const &message, FiLoc const &filoc)
{
    ASSERT1(m_filoc.IsValid());
    ASSERT1(m_input.is_open());
    std::cerr << filoc << ": error: " << message << std::endl;
    m_errors_were_encountered = true;
}

Parser::Token Scanner::ParseIntegerLiteral (char const *s, bool is_signed, Uint32 radix)
{
    ASSERT1(s != NULL);
    ASSERT1(radix == 2 || radix == 8 || radix == 10 || radix == 16);
    if (is_signed)
    {
        Sint32 value = strtol(s, NULL, radix);
        if (errno == ERANGE)
            EmitError("signed integer literal out of range", m_filoc);
        return Parser::Token(Parser::Terminal::SINT32, new SignedInteger(value));
    }
    else
    {
        Uint32 value = strtoul(s, NULL, radix);
        if (errno == ERANGE)
            EmitError("unsigned integer literal out of range", m_filoc);
        return Parser::Token(Parser::Terminal::UINT32, new UnsignedInteger(value));
    }
}

void Scanner::IncrementLineNumber (Uint32 by_value)
{
    m_filoc.IncrementLineNumber(by_value);
}

#line 102 "xrb_parse_datafile_scanner.cpp"

Scanner::Scanner ()
    :
    ReflexCpp_::AutomatonApparatus_(
        ms_state_table_,
        ms_state_count_,
        ms_transition_table_,
        ms_transition_count_,
        ms_accept_handler_count_),

#line 158 "xrb_parse_datafile_scanner.reflex"

    m_filoc(FiLoc::ms_invalid)

#line 117 "xrb_parse_datafile_scanner.cpp"

{
    DebugSpew(false);


#line 161 "xrb_parse_datafile_scanner.reflex"

//     DebugSpew(true);
    m_string_literal = NULL;
    m_warnings_were_encountered = false;
    m_errors_were_encountered = false;

#line 130 "xrb_parse_datafile_scanner.cpp"

    ResetForNewInput();
}

Scanner::~Scanner ()
{

#line 167 "xrb_parse_datafile_scanner.reflex"

    Close();

#line 142 "xrb_parse_datafile_scanner.cpp"
}

Scanner::StateMachine::Name Scanner::CurrentStateMachine () const
{
    assert(InitialState_() != NULL);
    BarfCpp_::Size initial_node_index = InitialState_() - ms_state_table_;
    assert(initial_node_index < ms_state_count_);
    switch (initial_node_index)
    {
        default: assert(false && "invalid initial node index -- this should never happen"); return StateMachine::START_;
        case 0: return StateMachine::BLOCK_COMMENT;
        case 10: return StateMachine::CHAR_LITERAL_END;
        case 17: return StateMachine::CHAR_LITERAL_GUTS;
        case 30: return StateMachine::MAIN;
        case 71: return StateMachine::STRING_LITERAL_GUTS;
    }
}

void Scanner::SwitchToStateMachine (StateMachine::Name state_machine)
{
    assert(
        state_machine == StateMachine::BLOCK_COMMENT ||
        state_machine == StateMachine::CHAR_LITERAL_END ||
        state_machine == StateMachine::CHAR_LITERAL_GUTS ||
        state_machine == StateMachine::MAIN ||
        state_machine == StateMachine::STRING_LITERAL_GUTS ||
        (false && "invalid StateMachine::Name"));
    REFLEX_CPP_DEBUG_CODE_(
        std::cerr << 
#line 196 "xrb_parse_datafile_scanner.reflex"
"DataFile::Scanner" << (m_filoc.IsValid() ? " ("+m_filoc.AsString()+")" : g_empty_string) << ":"
#line 174 "xrb_parse_datafile_scanner.cpp"
 << " switching to state machine "
                  << ms_state_machine_name_[state_machine];
        if (ms_state_machine_mode_flags_[state_machine] != 0)
        {
            if ((ms_state_machine_mode_flags_[state_machine] & AutomatonApparatus_::MF_CASE_INSENSITIVE_) != 0)
                std::cerr << " %case_insensitive";
            if ((ms_state_machine_mode_flags_[state_machine] & AutomatonApparatus_::MF_UNGREEDY_) != 0)
                std::cerr << " %ungreedy";
        }
        std::cerr << std::endl)
    InitialState_(ms_state_table_ + ms_state_machine_start_state_index_[state_machine]);
    ModeFlags_(ms_state_machine_mode_flags_[state_machine]);
    assert(CurrentStateMachine() == state_machine);
}

void Scanner::ResetForNewInput ()
{
    REFLEX_CPP_DEBUG_CODE_(
        std::cerr << 
#line 196 "xrb_parse_datafile_scanner.reflex"
"DataFile::Scanner" << (m_filoc.IsValid() ? " ("+m_filoc.AsString()+")" : g_empty_string) << ":"
#line 196 "xrb_parse_datafile_scanner.cpp"
 << " executing reset-for-new-input actions and switching to state machine "
                  << ms_state_machine_name_[StateMachine::START_];
        if (ms_state_machine_mode_flags_[StateMachine::START_] != 0)
        {
            if ((ms_state_machine_mode_flags_[StateMachine::START_] & AutomatonApparatus_::MF_CASE_INSENSITIVE_) != 0)
                std::cerr << " %case_insensitive";
            if ((ms_state_machine_mode_flags_[StateMachine::START_] & AutomatonApparatus_::MF_UNGREEDY_) != 0)
                std::cerr << " %ungreedy";
        }
        std::cerr << std::endl)
    ReflexCpp_::AutomatonApparatus_::ResetForNewInput_(ms_state_table_ + ms_state_machine_start_state_index_[StateMachine::START_], ms_state_machine_mode_flags_[StateMachine::START_]);
    assert(CurrentStateMachine() == StateMachine::START_);


#line 186 "xrb_parse_datafile_scanner.reflex"

    m_filoc = FiLoc::ms_invalid;
    delete m_string_literal;
    m_string_literal = NULL;
    m_warnings_were_encountered = false;
    m_errors_were_encountered = false;

#line 219 "xrb_parse_datafile_scanner.cpp"
}

Parser::Token Scanner::Scan () throw()
{

    std::string work_string;
    // this is the main scanner loop.  it only breaks when an accept handler
    // returns or after the unmatched character handler, if certain conditions
    // exist (see comments below).
    while (true)
    {
        // clear the previous accepted/rejected string.
        work_string.clear();
        // reset the char buffer and other stuff
        PrepareToScan_();

        bool was_at_end_of_input_ = IsAtEndOfInput();

        BarfCpp_::Uint32 accept_handler_index_ = RunDfa_(work_string);
        // if no valid accept_handler_index_ was returned, then work_string
        // was filled with everything up to the char after the keep_string
        // cursor (i.e. the rejected atom).
        if (accept_handler_index_ >= ms_accept_handler_count_)
        {
            // if we were already at the end of input and no
            // rule was matched, break out of the loop.
            if (was_at_end_of_input_)
                break;

            std::string &rejected_string = work_string;
            BarfCpp_::Uint8 rejected_atom = rejected_string.empty() ? '\0' : *rejected_string.rbegin();

            REFLEX_CPP_DEBUG_CODE_(
                std::cerr << 
#line 196 "xrb_parse_datafile_scanner.reflex"
"DataFile::Scanner" << (m_filoc.IsValid() ? " ("+m_filoc.AsString()+")" : g_empty_string) << ":"
#line 256 "xrb_parse_datafile_scanner.cpp"
 << " rejecting string ";
                PrintString_(rejected_string);
                std::cerr << " (rejected_atom is \'";
                PrintAtom_(rejected_atom);
                std::cerr << "\')" << std::endl)

            // execute the rejection actions.  the do/while loop is so that a
            // break statement inside the rejection actions doesn't break out
            // of the main scanner loop.
            do
            {

#line 182 "xrb_parse_datafile_scanner.reflex"

    ASSERT1(false && "this should never happen");
    EmitError("unrecognized character " + CharLiteral(rejected_atom), m_filoc);

#line 274 "xrb_parse_datafile_scanner.cpp"

            }
            while (false);
        }
        // otherwise, call the appropriate accept handler code.
        else
        {
            std::string &accepted_string = work_string;

            REFLEX_CPP_DEBUG_CODE_(
                std::cerr << 
#line 196 "xrb_parse_datafile_scanner.reflex"
"DataFile::Scanner" << (m_filoc.IsValid() ? " ("+m_filoc.AsString()+")" : g_empty_string) << ":"
#line 288 "xrb_parse_datafile_scanner.cpp"
 << " accepting string ";
                PrintString_(accepted_string);
                std::cerr << " in state machine " << ms_state_machine_name_[CurrentStateMachine()]
                          << " using regex (" << ms_accept_handler_regex_[accept_handler_index_] << ")" << std::endl)

            // execute the appropriate accept handler.
            // the accepted string is in accepted_string.
            switch (accept_handler_index_)
            {
                case 0:
                {

#line 372 "xrb_parse_datafile_scanner.reflex"

        IncrementLineNumber(NewlineCount(accepted_string));
        SwitchToStateMachine(StateMachine::MAIN);
    
#line 306 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 1:
                {

#line 378 "xrb_parse_datafile_scanner.reflex"

        IncrementLineNumber(NewlineCount(accepted_string));
        EmitWarning("unterminated block comment", GetFiLoc());
        return Parser::Terminal::END_;
    
#line 320 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 2:
                {

#line 451 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(m_char_literal != NULL);
        SwitchToStateMachine(StateMachine::MAIN);
        Character *char_literal = m_char_literal;
        m_char_literal = NULL;
        return Parser::Token(Parser::Terminal::CHARACTER, char_literal);
    
#line 336 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 3:
                {

#line 460 "xrb_parse_datafile_scanner.reflex"

        EmitError("unterminated character literal", GetFiLoc());
        ASSERT1(m_char_literal != NULL);
        delete m_char_literal;
        m_char_literal = NULL;
        SwitchToStateMachine(StateMachine::MAIN);
        return Parser::Terminal::END_;
    
#line 353 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 4:
                {

#line 470 "xrb_parse_datafile_scanner.reflex"

        EmitError("malformed character literal", GetFiLoc());
        if (accepted_string[0] == '\n')
            IncrementLineNumber();
        ASSERT1(m_char_literal != NULL);
        delete m_char_literal;
        m_char_literal = NULL;
        SwitchToStateMachine(StateMachine::MAIN);
        return Parser::Terminal::BAD_TOKEN;
    
#line 372 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 5:
                {

#line 388 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(accepted_string.length() >= 2);
        ASSERT1(accepted_string[0] == '\\');
        Uint32 value = strtol(accepted_string.c_str()+1, NULL, 8);
        if (value >= 0x100)
            EmitError("octal character literal value out of range (" + accepted_string + ")", GetFiLoc());
        ASSERT1(m_char_literal == NULL);
        m_char_literal = new Character(value);
        SwitchToStateMachine(StateMachine::CHAR_LITERAL_END);
    
#line 391 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 6:
                {

#line 400 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(accepted_string.length() >= 3);
        ASSERT1(accepted_string[0] == '\\');
        ASSERT1(accepted_string[1] == 'x');
        Uint32 value = strtol(accepted_string.c_str()+2, NULL, 16);
        if (value >= 0x100)
            EmitError("hexadecimal character literal value out of range (" + accepted_string + ")", GetFiLoc());
        ASSERT1(m_char_literal == NULL);
        m_char_literal = new Character(value);
        SwitchToStateMachine(StateMachine::CHAR_LITERAL_END);
    
#line 411 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 7:
                {

#line 413 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(accepted_string.length() == 2);
        ASSERT1(accepted_string[0] == '\\');
        ASSERT1(m_char_literal == NULL);
        m_char_literal = new Character(accepted_string[1]);
        m_char_literal->Escape();
        SwitchToStateMachine(StateMachine::CHAR_LITERAL_END);
    
#line 428 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 8:
                {

#line 423 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(accepted_string.length() == 1);
        ASSERT1(m_char_literal == NULL);
        m_char_literal = new Character(accepted_string[0]);
        SwitchToStateMachine(StateMachine::CHAR_LITERAL_END);
    
#line 443 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 9:
                {

#line 431 "xrb_parse_datafile_scanner.reflex"

        EmitError("unterminated character literal", GetFiLoc());
        ASSERT1(m_char_literal == NULL);
        return Parser::Terminal::END_;
    
#line 457 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 10:
                {

#line 438 "xrb_parse_datafile_scanner.reflex"

        EmitError("unexpected character " + CharLiteral(accepted_string[0]) + " in character literal", GetFiLoc());
        if (accepted_string[0] == '\n')
            IncrementLineNumber();
        ASSERT1(m_char_literal == NULL);
        m_char_literal = new Character(accepted_string[0]);
        SwitchToStateMachine(StateMachine::CHAR_LITERAL_END);
    
#line 474 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 11:
                {

#line 254 "xrb_parse_datafile_scanner.reflex"

        SwitchToStateMachine(StateMachine::BLOCK_COMMENT);
    
#line 486 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 12:
                {

#line 259 "xrb_parse_datafile_scanner.reflex"
 
#line 496 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 13:
                {

#line 262 "xrb_parse_datafile_scanner.reflex"

        SwitchToStateMachine(StateMachine::CHAR_LITERAL_GUTS);
    
#line 508 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 14:
                {

#line 267 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(m_string_literal == NULL);
        m_string_literal = new String();
        m_string_literal_starting_line_number = m_filoc.LineNumber();
        SwitchToStateMachine(StateMachine::STRING_LITERAL_GUTS);
    
#line 523 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 15:
                {

#line 275 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(accepted_string.length() == 1);
        return Parser::Token(accepted_string[0]);
    
#line 536 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 16:
                {

#line 281 "xrb_parse_datafile_scanner.reflex"

        // check if it matches any keywords
        std::string lowercase_text(accepted_string);
        Util::MakeLowercase(lowercase_text);
        if (lowercase_text == "true")
            return Parser::Token(Parser::Terminal::BOOLEAN, new Boolean(true));
        else if (lowercase_text == "false")
            return Parser::Token(Parser::Terminal::BOOLEAN, new Boolean(false));
        else
            return Parser::Token(Parser::Terminal::IDENTIFIER, new String(accepted_string));
    
#line 556 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 17:
                {

#line 294 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(accepted_string.length() >= 3); // must be at least "0b" followed by a binary digit
        bool is_signed = accepted_string[0] == '+' || accepted_string[0] == '-';
        ASSERT1((is_signed && accepted_string[1] == '0' && (accepted_string[2] == 'b' || accepted_string[2] == 'B'))
                ||
                (!is_signed && accepted_string[0] == '0' && (accepted_string[1] == 'b' || accepted_string[1] == 'B')));
        // if it's signed, stick the sign in front of the digits
        if (is_signed)
            accepted_string[2] = accepted_string[0];
        // start at the sign or the unsigned digits
        char const *s = accepted_string.c_str() + 2;
        return ParseIntegerLiteral(s, is_signed, 2);
    
#line 578 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 18:
                {

#line 309 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(accepted_string.length() >= 2); // must be at least "0" followed by an octal digit
        bool is_signed = accepted_string[0] == '+' || accepted_string[0] == '-';
        ASSERT1((is_signed && accepted_string[1] == '0')
                ||
                (!is_signed && accepted_string[0] == '0'));
        // if it's signed, stick the sign in front of the digits
        if (is_signed)
            accepted_string[1] = accepted_string[0];
        // start at the sign or the unsigned digits
        char const *s = accepted_string.c_str() + 1;
        return ParseIntegerLiteral(s, is_signed, 8);
    
#line 600 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 19:
                {

#line 324 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(accepted_string.length() >= 1); // must be at least a single decimal digit
        bool is_signed = accepted_string[0] == '+' || accepted_string[0] == '-';
        return ParseIntegerLiteral(accepted_string.c_str(), is_signed, 10);
    
#line 614 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 20:
                {

#line 331 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(accepted_string.length() >= 3); // must be at least "0x" followed by a hexadecimal digit
        bool is_signed = accepted_string[0] == '+' || accepted_string[0] == '-';
        ASSERT1((is_signed && accepted_string[1] == '0' && (accepted_string[2] == 'x' || accepted_string[2] == 'X'))
                ||
                (!is_signed && accepted_string[0] == '0' && (accepted_string[1] == 'x' || accepted_string[1] == 'X')));
        // if it's signed, stick the sign in front of the digits
        if (is_signed)
            accepted_string[2] = accepted_string[0];
        // start at the sign or the unsigned digits
        char const *s = accepted_string.c_str() + 2;
        return ParseIntegerLiteral(s, is_signed, 16);
    
#line 636 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 21:
                {

#line 346 "xrb_parse_datafile_scanner.reflex"

        Float value = strtof(accepted_string.c_str(), NULL);
        if (errno == ERANGE)
            EmitError("floating point literal out of range", m_filoc);
        return Parser::Token(Parser::Terminal::FLOATY, new Floaty(value));
    
#line 651 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 22:
                {

#line 354 "xrb_parse_datafile_scanner.reflex"
 
#line 661 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 23:
                {

#line 357 "xrb_parse_datafile_scanner.reflex"
 IncrementLineNumber(); 
#line 671 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 24:
                {

#line 360 "xrb_parse_datafile_scanner.reflex"
 return Parser::Terminal::END_; 
#line 681 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 25:
                {

#line 363 "xrb_parse_datafile_scanner.reflex"

        EmitError("unexpected character " + CharLiteral(accepted_string[0]), GetFiLoc());
        return Parser::Terminal::BAD_TOKEN;
    
#line 694 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 26:
                {

#line 485 "xrb_parse_datafile_scanner.reflex"

        ASSERT1(m_string_literal != NULL);
        IncrementLineNumber(NewlineCount(accepted_string));
        // get rid of the trailing endquote
        ASSERT1(accepted_string.length() >= 1);
        accepted_string.resize(accepted_string.length()-1);
        // escape the string in-place and handle the return code
        EscapeStringStatus status = EscapeString(accepted_string);
        switch (status.m_return_code)
        {
            case ESRC_SUCCESS:
                // awesome
                break;

            case ESRC_UNEXPECTED_EOI:
                ASSERT1(false && "the formulation of the regex should prevent this");
                break;

            case ESRC_MALFORMED_HEX_CHAR:
                EmitError(
                    "\\x with no trailing hex digits",
                    FiLoc(m_filoc.Filename(),
                          m_string_literal_starting_line_number + status.m_line_number_offset));
                break;

            case ESRC_HEX_ESCAPE_SEQUENCE_OUT_OF_RANGE:
            case ESRC_OCTAL_ESCAPE_SEQUENCE_OUT_OF_RANGE:
                EmitError(
                    "hex/octal escape sequence out of range",
                    FiLoc(m_filoc.Filename(),
                          m_string_literal_starting_line_number + status.m_line_number_offset));
                break;
        }
        m_string_literal->AppendString(accepted_string);
        SwitchToStateMachine(StateMachine::MAIN);
        String *string_literal = m_string_literal;
        m_string_literal = NULL;
        return Parser::Token(Parser::Terminal::STRING_FRAGMENT, string_literal);
    
#line 742 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                case 27:
                {

#line 526 "xrb_parse_datafile_scanner.reflex"

        EmitError("unterminated string literal", GetFiLoc());
        IncrementLineNumber(NewlineCount(accepted_string));
        ASSERT1(m_string_literal != NULL);
        delete m_string_literal;
        m_string_literal = NULL;
        return Parser::Terminal::END_;
    
#line 759 "xrb_parse_datafile_scanner.cpp"

                }
                break;

                default: assert(false && "this should never happen"); break;
            }
        }
    }


#line 170 "xrb_parse_datafile_scanner.reflex"

    ASSERT1(false && "you didn't handle EOF properly");
    return Parser::Terminal::END_;

#line 775 "xrb_parse_datafile_scanner.cpp"
}

// ///////////////////////////////////////////////////////////////////////
// begin internal reflex-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

void Scanner::PrintAtom_ (BarfCpp_::Uint8 atom)
{
    if (atom == '\\')                    std::cerr << "\\\\";
    else if (atom == '"')                std::cerr << "\\\"";
    else if (atom >= ' ' && atom <= '~') std::cerr << atom;
    else if (atom == '\n')               std::cerr << "\\n";
    else if (atom == '\t')               std::cerr << "\\t";
    else if (atom == '\0')               std::cerr << "\\0";
    else
    {
        std::cerr.width(2);
        std::cerr << "\\x" << std::hex << std::uppercase << BarfCpp_::Uint16(atom);
        std::cerr.width(1);
    }
}

void Scanner::PrintString_ (std::string const &s)
{
    // save the existing std::cerr properties for later restoration
    std::ios_base::fmtflags saved_stream_flags = std::cerr.flags();
    char saved_stream_fill = std::cerr.fill();
    std::streamsize saved_stream_width = std::cerr.width();
    std::streamsize saved_stream_precision = std::cerr.precision();

    // clear all format flags to a neutral state
    std::cerr.unsetf(
        std::ios_base::boolalpha|std::ios_base::dec|std::ios_base::fixed|
        std::ios_base::hex|std::ios_base::internal|std::ios_base::left|
        std::ios_base::oct|std::ios_base::right|std::ios_base::scientific|
        std::ios_base::showbase|std::ios_base::showpoint|std::ios_base::showpos|
        std::ios_base::skipws|std::ios_base::unitbuf|std::ios_base::uppercase|
        std::ios_base::adjustfield|std::ios_base::basefield|std::ios_base::floatfield);
    // the '0' char is used hex escape chars, which always have width 2
    std::cerr.fill('0');

    std::cerr << '"';
    for (std::string::size_type i = 0; i < s.size(); ++i)
        PrintAtom_(s[i]);
    std::cerr << '"';

    // restore the saved std::cerr properties
    std::cerr.setf(saved_stream_flags);
    std::cerr.fill(saved_stream_fill);
    std::cerr.width(saved_stream_width);
    std::cerr.precision(saved_stream_precision);
}

BarfCpp_::Uint32 const Scanner::ms_state_machine_start_state_index_[] =
{
    0,
    10,
    17,
    30,
    71,
};
BarfCpp_::Uint8 const Scanner::ms_state_machine_mode_flags_[] =
{
    2,
    0,
    0,
    0,
    2,
};
char const *const Scanner::ms_state_machine_name_[] =
{
    "BLOCK_COMMENT",
    "CHAR_LITERAL_END",
    "CHAR_LITERAL_GUTS",
    "MAIN",
    "STRING_LITERAL_GUTS",
};
BarfCpp_::Uint32 const Scanner::ms_state_machine_count_ = sizeof(Scanner::ms_state_machine_name_) / sizeof(*Scanner::ms_state_machine_name_);

// the order of the states indicates priority (only for accept states).
// the lower the state's index in this array, the higher its priority.
ReflexCpp_::AutomatonApparatus_::DfaState_ const Scanner::ms_state_table_[] =
{
    { 28, 2, ms_transition_table_+0 },
    { 28, 3, ms_transition_table_+2 },
    { 28, 2, ms_transition_table_+5 },
    { 1, 3, ms_transition_table_+7 },
    { 28, 2, ms_transition_table_+10 },
    { 28, 5, ms_transition_table_+12 },
    { 0, 2, ms_transition_table_+17 },
    { 0, 3, ms_transition_table_+19 },
    { 0, 3, ms_transition_table_+22 },
    { 1, 5, ms_transition_table_+25 },
    { 28, 2, ms_transition_table_+30 },
    { 28, 5, ms_transition_table_+32 },
    { 4, 0, ms_transition_table_+37 },
    { 2, 0, ms_transition_table_+37 },
    { 4, 2, ms_transition_table_+37 },
    { 3, 0, ms_transition_table_+39 },
    { 3, 5, ms_transition_table_+39 },
    { 28, 2, ms_transition_table_+44 },
    { 28, 9, ms_transition_table_+46 },
    { 10, 0, ms_transition_table_+55 },
    { 8, 0, ms_transition_table_+55 },
    { 10, 2, ms_transition_table_+55 },
    { 10, 5, ms_transition_table_+57 },
    { 7, 0, ms_transition_table_+62 },
    { 5, 1, ms_transition_table_+62 },
    { 5, 1, ms_transition_table_+63 },
    { 7, 3, ms_transition_table_+64 },
    { 6, 3, ms_transition_table_+67 },
    { 9, 5, ms_transition_table_+70 },
    { 9, 9, ms_transition_table_+75 },
    { 28, 2, ms_transition_table_+84 },
    { 28, 32, ms_transition_table_+86 },
    { 25, 0, ms_transition_table_+118 },
    { 22, 0, ms_transition_table_+118 },
    { 23, 0, ms_transition_table_+118 },
    { 14, 0, ms_transition_table_+118 },
    { 13, 0, ms_transition_table_+118 },
    { 25, 2, ms_transition_table_+118 },
    { 19, 8, ms_transition_table_+120 },
    { 28, 1, ms_transition_table_+128 },
    { 21, 3, ms_transition_table_+129 },
    { 28, 4, ms_transition_table_+132 },
    { 28, 2, ms_transition_table_+136 },
    { 21, 0, ms_transition_table_+138 },
    { 21, 1, ms_transition_table_+138 },
    { 18, 1, ms_transition_table_+139 },
    { 28, 1, ms_transition_table_+140 },
    { 17, 1, ms_transition_table_+141 },
    { 28, 4, ms_transition_table_+142 },
    { 28, 2, ms_transition_table_+146 },
    { 21, 1, ms_transition_table_+148 },
    { 28, 3, ms_transition_table_+149 },
    { 20, 6, ms_transition_table_+152 },
    { 28, 3, ms_transition_table_+158 },
    { 21, 5, ms_transition_table_+161 },
    { 28, 4, ms_transition_table_+166 },
    { 28, 2, ms_transition_table_+170 },
    { 21, 1, ms_transition_table_+172 },
    { 28, 4, ms_transition_table_+173 },
    { 28, 2, ms_transition_table_+177 },
    { 21, 1, ms_transition_table_+179 },
    { 19, 4, ms_transition_table_+180 },
    { 15, 0, ms_transition_table_+184 },
    { 25, 2, ms_transition_table_+184 },
    { 11, 0, ms_transition_table_+186 },
    { 12, 2, ms_transition_table_+186 },
    { 19, 8, ms_transition_table_+188 },
    { 19, 4, ms_transition_table_+196 },
    { 16, 4, ms_transition_table_+200 },
    { 16, 4, ms_transition_table_+204 },
    { 24, 32, ms_transition_table_+208 },
    { 28, 2, ms_transition_table_+240 },
    { 28, 5, ms_transition_table_+242 },
    { 28, 2, ms_transition_table_+247 },
    { 27, 5, ms_transition_table_+249 },
    { 26, 2, ms_transition_table_+254 },
    { 26, 5, ms_transition_table_+256 },
    { 28, 2, ms_transition_table_+261 },
    { 28, 1, ms_transition_table_+263 },
    { 27, 1, ms_transition_table_+264 },
    { 26, 5, ms_transition_table_+265 }
};
BarfCpp_::Size const Scanner::ms_state_count_ = sizeof(Scanner::ms_state_table_) / sizeof(*Scanner::ms_state_table_);

ReflexCpp_::AutomatonApparatus_::DfaTransition_ const Scanner::ms_transition_table_[] =
{
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+1 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+3 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 42, 0, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 41, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 43, 255, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+1 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+3 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 42, 0, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 41, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 43, 255, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+9 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 42, 0, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 47, 0, ms_state_table_+6 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 41, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 43, 46, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 255, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+7 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+8 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 42, 0, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 41, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 43, 255, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 42, 0, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 41, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 43, 255, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 42, 0, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 47, 0, ms_state_table_+6 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 41, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 43, 46, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 255, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+11 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+16 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 39, 0, ms_state_table_+13 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 38, ms_state_table_+12 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 40, 91, ms_state_table_+12 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 93, 255, ms_state_table_+12 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+12 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+15 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 39, 0, ms_state_table_+13 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 38, ms_state_table_+12 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 40, 91, ms_state_table_+12 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 93, 255, ms_state_table_+12 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+18 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 39, 0, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+21 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 31, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 32, 33, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 35, 38, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 40, 91, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 93, 126, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 127, 255, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+22 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+28 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 120, 0, ms_state_table_+26 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 32, 47, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 55, ms_state_table_+24 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 56, 119, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 121, 126, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 55, ms_state_table_+25 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 55, ms_state_table_+25 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+27 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 65, 70, ms_state_table_+27 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 97, 102, ms_state_table_+27 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+27 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 65, 70, ms_state_table_+27 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 97, 102, ms_state_table_+27 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 120, 0, ms_state_table_+26 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 32, 47, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 55, ms_state_table_+24 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 56, 119, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 121, 126, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 39, 0, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+21 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 31, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 32, 33, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 35, 38, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 40, 91, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 93, 126, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 127, 255, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+31 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+70 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 9, 0, ms_state_table_+33 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 10, 0, ms_state_table_+34 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 32, 0, ms_state_table_+33 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 33, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+35 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 39, 0, ms_state_table_+36 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 43, 0, ms_state_table_+37 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 44, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 45, 0, ms_state_table_+37 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 46, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 47, 0, ms_state_table_+63 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+66 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 58, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 59, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 91, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 93, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 94, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 95, 0, ms_state_table_+68 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 96, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 123, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 124, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 125, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 8, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 11, 31, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 35, 38, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 40, 42, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+67 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 60, 64, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 65, 90, ms_state_table_+68 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 97, 122, ms_state_table_+68 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 126, 255, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+38 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+61 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 46, 0, ms_state_table_+39 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 66, 0, ms_state_table_+46 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 69, 0, ms_state_table_+48 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 88, 0, ms_state_table_+51 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 98, 0, ms_state_table_+46 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 101, 0, ms_state_table_+48 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 120, 0, ms_state_table_+51 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 55, ms_state_table_+45 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+40 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 69, 0, ms_state_table_+41 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 101, 0, ms_state_table_+41 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+40 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 43, 0, ms_state_table_+42 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 45, 0, ms_state_table_+42 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+43 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+44 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+43 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+44 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+44 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 55, ms_state_table_+45 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 49, ms_state_table_+47 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 49, ms_state_table_+47 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 43, 0, ms_state_table_+49 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 45, 0, ms_state_table_+49 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+43 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+50 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+43 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+50 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+50 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+52 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 65, 70, ms_state_table_+52 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 97, 102, ms_state_table_+52 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 46, 0, ms_state_table_+53 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 80, 0, ms_state_table_+58 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 112, 0, ms_state_table_+58 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+52 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 65, 70, ms_state_table_+52 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 97, 102, ms_state_table_+52 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+54 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 65, 70, ms_state_table_+54 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 97, 102, ms_state_table_+54 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 80, 0, ms_state_table_+55 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 112, 0, ms_state_table_+55 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+54 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 65, 70, ms_state_table_+54 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 97, 102, ms_state_table_+54 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 43, 0, ms_state_table_+56 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 45, 0, ms_state_table_+56 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+43 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+57 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+43 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+57 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+57 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 43, 0, ms_state_table_+59 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 45, 0, ms_state_table_+59 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+43 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+60 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+43 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+60 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+60 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 46, 0, ms_state_table_+39 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 69, 0, ms_state_table_+48 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 101, 0, ms_state_table_+48 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+61 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 42, 0, ms_state_table_+64 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 47, 0, ms_state_table_+65 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 9, ms_state_table_+65 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 11, 255, ms_state_table_+65 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 46, 0, ms_state_table_+39 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 66, 0, ms_state_table_+46 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 69, 0, ms_state_table_+48 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 88, 0, ms_state_table_+51 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 98, 0, ms_state_table_+46 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 101, 0, ms_state_table_+48 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 120, 0, ms_state_table_+51 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 55, ms_state_table_+45 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 46, 0, ms_state_table_+39 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 69, 0, ms_state_table_+48 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 101, 0, ms_state_table_+48 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+61 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 95, 0, ms_state_table_+69 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+69 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 65, 90, ms_state_table_+69 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 97, 122, ms_state_table_+69 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 95, 0, ms_state_table_+69 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+69 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 65, 90, ms_state_table_+69 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 97, 122, ms_state_table_+69 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 9, 0, ms_state_table_+33 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 10, 0, ms_state_table_+34 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 32, 0, ms_state_table_+33 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 33, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+35 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 39, 0, ms_state_table_+36 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 43, 0, ms_state_table_+37 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 44, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 45, 0, ms_state_table_+37 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 46, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 47, 0, ms_state_table_+63 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+66 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 58, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 59, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 91, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 93, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 94, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 95, 0, ms_state_table_+68 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 96, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 123, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 124, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 125, 0, ms_state_table_+62 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 8, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 11, 31, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 35, 38, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 40, 42, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+67 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 60, 64, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 65, 90, ms_state_table_+68 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 97, 122, ms_state_table_+68 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 126, 255, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+72 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+74 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+75 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+77 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 33, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 35, 91, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 93, 255, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+72 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+74 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+75 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+77 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 33, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 35, 91, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 93, 255, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+76 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+80 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+75 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+77 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 33, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 35, 91, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 93, 255, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+78 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+79 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 255, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 255, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+75 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+77 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 1, 33, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 35, 91, ms_state_table_+73 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::INPUT_ATOM_RANGE, 93, 255, ms_state_table_+73 }
};
BarfCpp_::Size const Scanner::ms_transition_count_ = sizeof(Scanner::ms_transition_table_) / sizeof(*Scanner::ms_transition_table_);

char const *const Scanner::ms_accept_handler_regex_[] =
{
    "{ANY}*[*]/",
    "{ANY}*{EOF}",
    "'",
    "\\\\?{EOF}",
    "{ANY}",
    "{OCT_CHAR}",
    "{HEX_CHAR}",
    "{CHAR_ESC_CHAR}",
    "{CHAR_NORMAL_CHAR}",
    "\\\\?{EOF}",
    "{ANY}",
    "/[*]",
    "//.*",
    "'",
    "\"",
    "{OPERATOR}",
    "{IDENTIFIER}",
    "{BIN}",
    "{OCT}",
    "{DEC}",
    "{HEX}",
    "{DEC_FLOAT}|{HEX_FLOAT}",
    "{WHITESPACE}",
    "{NEWLINE}",
    "{EOF}",
    ".",
    "([^\\\\]|\\\\{ANY})*\"",
    "([^\\\\]|\\\\{ANY})*\\\\?{EOF}"
};
BarfCpp_::Uint32 const Scanner::ms_accept_handler_count_ = sizeof(Scanner::ms_accept_handler_regex_) / sizeof(*Scanner::ms_accept_handler_regex_);

// ///////////////////////////////////////////////////////////////////////
// end of internal reflex-generated parser guts
// ///////////////////////////////////////////////////////////////////////


#line 174 "xrb_parse_datafile_scanner.reflex"

} // end of namespace DataFile
} // end of namespace Parse
} // end of namespace Xrb

#line 1262 "xrb_parse_datafile_scanner.cpp"
