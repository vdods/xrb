%{

// ///////////////////////////////////////////////////////////////////////////
// xrb_linecalculatorparser.ypp by Victor Dods, created 2005/07/21
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

#include "xrb.h"

#include "xrb_math.h"

using namespace Xrb;

#define YYSTYPE Float

int LineCalculator_lex (YYSTYPE *yylval, void *line_calculator_scanner);
int LineCalculator_error (char const *error_string);

#define YYPARSE_PARAM \
    line_calculator_scanner, \
    Float *calculated_value
#define YYLEX_PARAM line_calculator_scanner

%}

%pure_parser

%token FLOAT
%token SIN
%token COS
%token TAN
%token ASIN
%token ACOS
%token ATAN
%token EXP
%token E
%token LN
%token LOG

%token END_OF_FILE

%token '(' ')'

%left '-' '+'
%left '*' '/' MULTIPLICATION
%right UNARY
%right '^'

%start ROOT

%%

ROOT
:
    EXPRESSION END_OF_FILE
    {
        ASSERT1(calculated_value != NULL)
        $$ = $1;
        *calculated_value = $$;
        YYACCEPT;
    }
;

EXPRESSION
:
    EXPRESSION '+' EXPRESSION
    {
        $$ = $1 + $3;
    }
|
    EXPRESSION '-' EXPRESSION
    {
        $$ = $1 - $3;
    }
|
    EXPRESSION '*' EXPRESSION
    {
        $$ = $1 * $3;
    }
    /*
|
    EXPRESSION EXPRESSION %prec MULTIPLICATION
    {
        $$ = $1 * $2;
    }*/
|
    EXPRESSION '/' EXPRESSION
    {
        // avoid divide-by-zero
        if ($3 != static_cast<Float>(0))
            $$ = $1 / $3;
        // if dividing by zero, explicitly return not-a-number
        else
            $$ = Math::Nan();
    }
|
    '-' EXPRESSION %prec UNARY
    {
        $$ = -$2;
    }
|
    '+' EXPRESSION %prec UNARY
    {
        $$ = $2;
    }
|
    EXPRESSION '^' EXPRESSION
    {
        // if the exponentiation wouldn't result in a complex number, return it.
        if ($1 >= static_cast<Float>(0) || $3 == Math::Round($3))
            $$ = Math::Pow($1, $3);
        // otherwise return not-a-number
        else
            $$ = Math::Nan();
    }
|
    '(' EXPRESSION ')'
    {
        $$ = $2;
    }
|
    SIN EXPRESSION %prec UNARY
    {
        $$ = Math::Sin($2);
    }
|
    COS EXPRESSION %prec UNARY
    {
        $$ = Math::Cos($2);
    }
|
    TAN EXPRESSION %prec UNARY
    {
        $$ = Math::Tan($2);
    }
|
    ASIN EXPRESSION %prec UNARY
    {
        // if the argument is within the domain, return the computed value.
        if ($1 >= static_cast<Float>(-1) && $1 <= static_cast<Float>(1))
            $$ = Math::Asin($2);
        // otherwise return not-a-number.
        else
            $$ = Math::Nan();
    }
|
    ACOS EXPRESSION %prec UNARY
    {
        // if the argument is within the domain, return the computed value.
        if ($1 >= static_cast<Float>(-1) && $1 <= static_cast<Float>(1))
            $$ = Math::Acos($2);
        // otherwise return not-a-number.
        else
            $$ = Math::Nan();
    }
|
    ATAN EXPRESSION %prec UNARY
    {
        $$ = Math::Atan($2);
    }
|
    EXP EXPRESSION %prec UNARY
    {
        $$ = Math::ExpBaseE($2);
    }
|
/*    E EXPRESSION %prec UNARY
    {
        $$ = Math::ExpBase10($2);
    }
|*/
    FLOAT E EXPRESSION %prec UNARY
    {
        $$ = $1 * Math::ExpBase10($3);
    }
|
    LN EXPRESSION %prec UNARY
    {
        // if the argument is within the domain, return the computed value.
        if ($1 > static_cast<Float>(0))
            $$ = Math::LogBaseE($2);
        // otherwise return not-a-number.
        else
            $$ = Math::Nan();
    }
|
    LOG EXPRESSION %prec UNARY
    {
        // if the argument is within the domain, return the computed value.
        if ($1 > static_cast<Float>(0))
            $$ = Math::LogBase10($2);
        // otherwise return not-a-number.
        else
            $$ = Math::Nan();
    }
|
    FLOAT
    {
        $$ = $1;
    }
;

%%

int LineCalculator_error (char const *error_string)
{
    fprintf(stderr, "LineCalculator_error(); parse error \"%s\"\n", error_string);
    return 0;
}

