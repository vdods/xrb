// ///////////////////////////////////////////////////////////////////////////
// xrb_arithmeticparser.trison by Victor Dods, created 2006/08/25
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

%parser_header_file_top%{
#include "xrb.h"

namespace Xrb
{

class ArithmeticScanner;
%} // end of %parser_header_file_top

%parser_class_name "ArithmeticParser"

%parser_parse_method_access "private:"

%parser_class_methods_and_members{
    Float Parse (std::string const &input_string);

private:

    Token::Type Scan ();

    ArithmeticScanner *m_scanner;
} // end of %parser_class_methods_and_members

%parser_header_file_bottom%{
} // end of namespace Xrb
%} // end of %parser_header_file_bottom

%parser_implementation_file_top%{
#include "xrb_arithmeticscanner.h"

#include "xrb_math.h"

namespace Xrb
{
%} // end of %parser_implementation_file_top

%parser_constructor_actions{
    m_scanner = NULL;
}

%parser_destructor_actions{
    ASSERT1(m_scanner == NULL)
}

%parser_implementation_file_bottom%{
Float ArithmeticParser::Parse (std::string const &input_string)
{
    ASSERT1(m_scanner == NULL)

    Float retval;

    m_scanner = new ArithmeticScanner(input_string);
    if (Parse() == PRC_SUCCESS)
        retval = GetAcceptedToken();
    else
        retval = Math::Nan();
    DeleteAndNullify(m_scanner);

    return retval;
}

ArithmeticParser::Token::Type ArithmeticParser::Scan ()
{
    ASSERT1(m_scanner != NULL)
    return m_scanner->Scan(&m_lookahead_token);
}

} // end of namespace Xrb
%} // end of %parser_implementation_file_bottom

%parser_base_assigned_type "Float"
%parser_base_assigned_type_sentinel "0.0f"

%token BAD_TOKEN
%token NUMERIC
%token '+' '-' '*' '/' '^' '(' ')'

%prec ADDITION
%prec MULTIPLICATION
%prec UNARY
%prec EXPONENTIATION

%start exp

%%

exp
:
    exp:left '+' exp:right %prec ADDITION       { return left + right; }
|
    exp:left '-' exp:right %prec ADDITION       { return left - right; }
|
    exp:left '*' exp:right %prec MULTIPLICATION { return left * right; }
|
    exp:left '/' exp:right %prec MULTIPLICATION { return (right == 0.0f) ? Math::Nan() : left / right; }
|
    '+' exp:exp            %prec UNARY          { return exp; }
|
    '-' exp:exp            %prec UNARY          { return -exp; }
|
    exp:left '^' exp:right %prec EXPONENTIATION { return Math::Pow(left, right); }
|
    '(' exp:exp ')'                             { return exp; }
|
    NUMERIC:numeric                             { return numeric; }
;
