// ///////////////////////////////////////////////////////////////////////////
// xrb_datafileparser.trison by Victor Dods, created 2006/07/15
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

%parser_header_file_top%{
#include "xrb.h"

#include <string>

namespace Xrb
{

class DataFileKeyPair;
class DataFileLocation;
class DataFileScanner;
class DataFileValue;
%} // end of %parser_header_file_top

%parser_class_name "DataFileParser"

%parser_parse_method_access "private:"

%parser_class_methods_and_members{
    enum ReturnCode
    {
        RC_SUCCESS = 0,
        RC_INVALID_FILENAME,
        RC_FILE_OPEN_FAILURE,
        RC_PARSE_ERROR,
        RC_ERRORS_ENCOUNTERED
    }; // end of enum ReturnCode

    inline DataFileKeyPair *GetAcceptedKeyPair () const
    {
        return DStaticCast<DataFileKeyPair *>(GetAcceptedToken());
    }
    inline DataFileKeyPair *StealAcceptedKeyPair ()
    {
        DataFileKeyPair *accepted_key_pair = GetAcceptedKeyPair();
        ClearAcceptedToken();
        return accepted_key_pair;
    }

    ReturnCode Parse (std::string const &input_filename);

private:

    Token::Type Scan ();

    void EmitWarning (std::string const &message);
    void EmitWarning (DataFileLocation const &file_location, std::string const &message);

    void EmitError (std::string const &message);
    void EmitError (DataFileLocation const &file_location, std::string const &message);

    DataFileScanner *m_scanner;
} // end of %parser_class_methods_and_members

%parser_header_file_bottom%{
} // end of namespace Xrb
%} // end of %parser_header_file_bottom

%parser_implementation_file_top%{
#include <sstream>

#include "xrb_datafilelocation.h"
#include "xrb_datafilescanner.h"
#include "xrb_datafilevalue.h"

#undef FL
#define FL DataFileLocation(m_scanner->GetInputFilename(), m_scanner->GetLineNumber())

namespace Xrb
{
%} // end of %parser_implementation_file_top

%parser_constructor_actions{
    m_scanner = new DataFileScanner();
}

%parser_destructor_actions{
    ASSERT1(m_scanner != NULL)
    Delete(m_scanner);
    delete StealAcceptedKeyPair();
}

%parser_start_of_parse_method_actions%{
    delete StealAcceptedKeyPair();
%}

%parser_end_of_parse_method_actions%{
    m_scanner->Close();
%}

%parser_throw_away_token_actions{
    Delete(token);
}

%parser_implementation_file_bottom%{
DataFileParser::ReturnCode DataFileParser::Parse (std::string const &input_filename)
{
    ASSERT1(m_scanner != NULL)
    ASSERT1(!m_scanner->GetIsOpen())
    // if there are any pipe characters in the filename, return failure
    if (input_filename.find_first_of("|") != static_cast<std::string::size_type>(-1))
        return RC_INVALID_FILENAME;

    // attempt to open the filename and return the result
    if (!m_scanner->Open(input_filename))
        return RC_FILE_OPEN_FAILURE;

    // start parsing, and return parse error if we got an unhandled error
    if (Parse() == PRC_UNHANDLED_PARSE_ERROR)
        return RC_PARSE_ERROR;

    // if any errors were encountered, return parse error
    if (m_scanner->GetWereErrorsEncountered())
        return RC_ERRORS_ENCOUNTERED;

    // otherwise return success
    return RC_SUCCESS;
}

DataFileParser::Token::Type DataFileParser::Scan ()
{
    ASSERT1(m_scanner != NULL)
    return m_scanner->Scan(&m_lookahead_token);
}

void DataFileParser::EmitWarning (std::string const &message)
{
    ASSERT1(m_scanner != NULL)
    m_scanner->EmitWarning(message);
}

void DataFileParser::EmitWarning (DataFileLocation const &file_location, std::string const &message)
{
    ASSERT1(m_scanner != NULL)
    m_scanner->EmitWarning(file_location, message);
}

void DataFileParser::EmitError (std::string const &message)
{
    ASSERT1(m_scanner != NULL)
    m_scanner->EmitError(message);
}

void DataFileParser::EmitError (DataFileLocation const &file_location, std::string const &message)
{
    ASSERT1(m_scanner != NULL)
    m_scanner->EmitError(file_location, message);
}

} // end of namespace Xrb
%} // end of %parser_implementation_file_bottom

%parser_base_assigned_type "DataFileValue *"
%parser_base_assigned_type_sentinel "NULL"

%parser_custom_cast "DStaticCast"

%token ERROR
%token BOOLEAN %type "DataFileBoolean *"
%token INTEGER %type "DataFileInteger *"
%token FLOAT %type "DataFileFloat *"
%token CHARACTER %type "DataFileCharacter *"
%token STRING_FRAGMENT %type "DataFileString *"
%token IDENTIFIER %type "DataFileString *"
%token ';' ',' '+' '-' '{' '}' '[' ']'

%start data_file

%%

data_file %type "DataFileStructure *"
:
    element_list:element_list
    {
        ASSERT1(element_list != NULL)
        return new DataFileKeyPair(m_scanner->GetInputFilename(), element_list);
    }
|
    %error
    {
        EmitError(FL, "general syntax error");
        return new DataFileKeyPair(m_scanner->GetInputFilename(), new DataFileStructure());
    }
;

element_list %type "DataFileStructure *"
:
    element_list:element_list element:element
    {
        ASSERT1(element_list != NULL)

        if (element != NULL)
        {
            try
            {
                element_list->AddKeyPair(element);
            }
            catch (std::string const &exception)
            {
                EmitError(FL, exception);
                Delete(element);
            }
        }
        return element_list;
    }
|
    {
        return new DataFileStructure();
    }
;

element %type "DataFileKeyPair *"
:
    IDENTIFIER:key value:value ';'
    {
        ASSERT1(key != NULL)
        if (value == NULL)
        {
            Delete(key);
            return NULL;
        }

        DataFileKeyPair *key_pair = new DataFileKeyPair(key->GetValue(), value);
        Delete(key);
        return key_pair;
    }
|
    IDENTIFIER:key %error ';'
    {
        ASSERT1(key != NULL)
        std::ostringstream out;
        out << "syntax error in element with key \"" << key->GetValue() << "\"";
        EmitError(FL, out.str());
        Delete(key);
        return NULL;
    }
|
    %error ';'
    {
        EmitError(FL, "syntax error in element");
        return NULL;
    }
;

structure %type "DataFileStructure *"
:
    '{' element_list:element_list '}'
    {
        ASSERT1(element_list != NULL)
        return element_list;
    }
|
    '{' %error '}'
    {
        EmitError(FL, "syntax error in structure");
        return new DataFileStructure();
    }
;

array %type "DataFileArray *"
:
    '[' value_list:value_list ']'
    {
        ASSERT1(value_list != NULL)
        return value_list;
    }
|
    '[' value_list:value_list ',' ']'
    {
        ASSERT1(value_list != NULL)
        return value_list;
    }
|
    '[' ']'
    {
        return new DataFileArray();
    }
|
    '[' %error ']'
    {
        EmitError(FL, "syntax error in array");
        return NULL;
    }
;

value_list %type "DataFileArray *"
:
    value_list:value_list ',' value:value
    {
        ASSERT1(value_list != NULL)
        if (value != NULL)
        {
            try
            {
                value_list->AppendValue(value);
            }
            catch (std::string const &exception)
            {
                EmitError(FL, exception);
                Delete(value);
            }
        }
        return value_list;
    }
|
    value:value
    {
        DataFileArray *value_list = new DataFileArray();
        if (value != NULL)
        {
            try
            {
                value_list->AppendValue(value);
            }
            catch (std::string const &)
            {
                ASSERT1(false && "this should never happen")
                Delete(value);
            }
        }
        return value_list;
    }
;

value %type "DataFileValue *"
:
    BOOLEAN:value
    {
        return value;
    }
|
    integer:value
    {
        return value;
    }
|
    float:value
    {
        return value;
    }
|
    CHARACTER:value
    {
        return value;
    }
|
    string:value
    {
        return value;
    }
|
    structure:value
    {
        return value;
    }
|
    array:value
    {
        return value;
    }
/*
|
    %error
    {
        EmitError(FL, "syntax error in value");
        return NULL;
    }
*/
;

integer %type "DataFileInteger *"
:
    INTEGER:value
    {
        ASSERT1(value != NULL)
        return value;
    }
|
    '+' INTEGER:value
    {
        ASSERT1(value != NULL)
        try
        {
            value->Sign(POSITIVE);
        }
        catch (std::string const &exception)
        {
            EmitError(FL, exception);
        }
        return value;
    }
|
    '-' INTEGER:value
    {
        ASSERT1(value != NULL)
        try
        {
            value->Sign(NEGATIVE);
        }
        catch (std::string const &exception)
        {
            EmitError(FL, exception);
        }
        return value;
    }
;

float %type "DataFileFloat *"
:
    FLOAT:value
    {
        ASSERT1(value != NULL)
        return value;
    }
|
    '+' FLOAT:value
    {
        ASSERT1(value != NULL)
        value->Sign(POSITIVE);
        return value;
    }
|
    '-' FLOAT:value
    {
        ASSERT1(value != NULL)
        value->Sign(NEGATIVE);
        return value;
    }
;

string %type "DataFileString *"
:
    string:string '+' STRING_FRAGMENT:string_fragment
    {
        ASSERT1(string != NULL)
        ASSERT1(string_fragment != NULL)
        string->AppendString(string_fragment->GetValue());
        Delete(string_fragment);
        return string;
    }
|
    STRING_FRAGMENT:string_fragment
    {
        ASSERT1(string_fragment != NULL)
        return string_fragment;
    }
|
    string:string STRING_FRAGMENT:string_fragment
    {
        ASSERT1(string != NULL)
        ASSERT1(string_fragment != NULL)
        string->AppendString(string_fragment->GetValue());
        Delete(string_fragment);
        EmitError(FL, "use + to concatenate strings (or did you forget a comma?)");
        return string;
    }
;
