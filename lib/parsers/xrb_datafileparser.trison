// ///////////////////////////////////////////////////////////////////////////
// xrb_datafileparser.trison by Victor Dods, created 2006/07/15
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

%parser_header_file_top%{
#include "xrb.h"

#include <string>

namespace Xrb
{

class DataFileKeyPair;
class DataFileLocation;
class DataFileScanner;
class DataFileValue;
%} // end of %parser_header_file_top

%parser_class_name "DataFileParser"

%parser_class_methods_and_members{
    inline bool GetWereWarningsEncountered () const { return m_were_warnings_encountered; }
    inline bool GetWereErrorsEncountered () const { return m_were_errors_encountered; }
    inline DataFileKeyPair *GetAcceptedKeyPair () const
    {
        return DStaticCast<DataFileKeyPair *>(GetAcceptedToken());
    }

    bool SetInputFilename (std::string const &input_filename);

    Token::Type Scan ();

private:

    void EmitWarning (std::string const &message);
    void EmitWarning (DataFileLocation const &file_location, std::string const &message);

    void EmitError (std::string const &message);
    void EmitError (DataFileLocation const &file_location, std::string const &message);

    DataFileScanner *m_scanner;
    bool m_were_warnings_encountered;
    bool m_were_errors_encountered;
} // end of %parser_class_methods_and_members

%parser_header_file_bottom%{
} // end of namespace Xrb
%} // end of %parser_header_file_bottom

%parser_implementation_file_top%{
#include <sstream>

#include "xrb_datafilelocation.h"
#include "xrb_datafilescanner.h"
#include "xrb_datafilevalue.h"

#undef FL
#define FL DataFileLocation(m_scanner->GetInputFilename(), m_scanner->GetLineNumber())

namespace Xrb
{
%} // end of %parser_implementation_file_top

%parser_constructor_actions{
    m_scanner = new DataFileScanner();
}

%parser_destructor_actions{
    ASSERT1(m_scanner != NULL)
    Delete(m_scanner);
}

%parser_start_of_parse_method_actions{
    m_were_warnings_encountered = false;
    m_were_errors_encountered = false;
}

%parser_end_of_parse_method_actions{
    m_scanner->Close();
}

%parser_throw_away_token_actions{
    Delete(token);
}

%parser_implementation_file_bottom%{
bool DataFileParser::SetInputFilename (std::string const &input_filename)
{
    ASSERT1(m_scanner != NULL)
    m_scanner->Close();
    // if there are any pipe characters in the filename, return failure
    if (input_filename.find_first_of("|") != static_cast<std::string::size_type>(-1))
        return false;
    // otherwise attempt to open the filename and return the result
    else
        return m_scanner->Open(input_filename);
}

DataFileParser::Token::Type DataFileParser::Scan ()
{
    ASSERT1(m_scanner != NULL)
    return m_scanner->Scan(&m_lookahead_token);
}

void DataFileParser::EmitWarning (std::string const &message)
{
    ASSERT1(m_scanner != NULL)
    std::cerr << m_scanner->GetInputFilename() << ": warning: " << message << std::endl;
    m_were_warnings_encountered = true;
}

void DataFileParser::EmitWarning (DataFileLocation const &file_location, std::string const &message)
{
    std::cerr << file_location << ": warning: " << message << std::endl;
    m_were_warnings_encountered = true;
}

void DataFileParser::EmitError (std::string const &message)
{
    ASSERT1(m_scanner != NULL)
    std::cerr << m_scanner->GetInputFilename() << ": error: " << message << std::endl;
    m_were_errors_encountered = true;
}

void DataFileParser::EmitError (DataFileLocation const &file_location, std::string const &message)
{
    std::cerr << file_location << ": error: " << message << std::endl;
    m_were_errors_encountered = true;
}

} // end of namespace Xrb
%} // end of %parser_implementation_file_bottom

%parser_base_assigned_type "DataFileValue *"
%parser_base_assigned_type_sentinel "NULL"

%parser_custom_cast "DStaticCast"

%token ERROR
%token BOOLEAN %type "DataFileBoolean *"
%token INTEGER %type "DataFileInteger *"
%token FLOAT %type "DataFileFloat *"
%token CHARACTER %type "DataFileCharacter *"
%token STRING_FRAGMENT %type "DataFileString *"
%token IDENTIFIER %type "DataFileString *"
%token ';' ',' '-' '{' '}' '[' ']'

%start data_file

%%

data_file %type "DataFileStructure *"
:
    element_list:element_list
    {
        ASSERT1(element_list != NULL)
        return new DataFileKeyPair(m_scanner->GetInputFilename(), element_list);
    }
|
    %error
    {
        EmitError(FL, "general syntax error");
        return new DataFileKeyPair(m_scanner->GetInputFilename(), new DataFileStructure());
    }
;

element_list %type "DataFileStructure *"
:
    element_list:element_list element:element
    {
        ASSERT1(element_list != NULL)

        if (element != NULL)
        {
            try
            {
                element_list->AddKeyPair(element);
            }
            catch (char const *exception)
            {
                std::ostringstream out;
                out << "collision with key \"" << element->GetKey() << "\"";
                EmitError(FL, out.str());
                Delete(element);
            }
        }
        return element_list;
    }
|
    {
        return new DataFileStructure();
    }
;

element %type "DataFileKeyPair *"
:
    key_pair:key_pair ';'
    {
        return key_pair;
    }
|
    %error ';'
    {
        EmitError(FL, "syntax error in element");
        return NULL;
    }
;

key_pair %type "DataFileKeyPair *"
:
    IDENTIFIER:key value:value
    {
        ASSERT1(key != NULL)
        if (value == NULL)
        {
            Delete(key);
            return NULL;
        }

        DataFileKeyPair *key_pair = new DataFileKeyPair(key->GetValue(), value);
        Delete(key);
        return key_pair;
    }
|
    IDENTIFIER:key value:value %error
    {
        ASSERT1(key != NULL)
        std::ostringstream out;
        out << "syntax error in element with key \"" << key->GetValue() << "\"";
        EmitError(FL, out.str());
        Delete(key);
        if (value != NULL)
            Delete(value);
        return NULL;
    }
|
    IDENTIFIER:key %error
    {
        ASSERT1(key != NULL)
        std::ostringstream out;
        out << "syntax error in element with key \"" << key->GetValue() << "\"";
        EmitError(FL, out.str());
        Delete(key);
        return NULL;
    }
;

structure %type "DataFileStructure *"
:
    '{' element_list:element_list '}'
    {
        ASSERT1(element_list != NULL)
        return element_list;
    }
|
    '{' %error '}'
    {
        EmitError(FL, "syntax error in structure");
        return new DataFileStructure();
    }
;

array %type "DataFileArray *"
:
    '[' list:list ']'
    {
        ASSERT1(list != NULL)
        return list;
    }
|
    '[' list:list ',' ']'
    {
        ASSERT1(list != NULL)
        return list;
    }
|
    '[' ']'
    {
        return new DataFileArray();
    }
|
    '[' %error ']'
    {
        EmitError(FL, "syntax error in array");
        return NULL;
    }
;

list %type "DataFileArray *"
:
    list:list ',' list_element:list_element
    {
        ASSERT1(list != NULL)
        if (list_element != NULL)
        {
            try
            {
                list->AppendValue(list_element);
            }
            catch (char const *exception)
            {
                EmitError(FL, exception);
                Delete(list_element);
            }
        }
        return list;
    }
|
    list_element:list_element
    {
        DataFileArray *list = new DataFileArray();
        if (list_element != NULL)
        {
            try
            {
                list->AppendValue(list_element);
            }
            catch (char const *exception)
            {
                ASSERT1(false && "this should never happen")
                Delete(list_element);
            }
        }
        return list;
    }
;

list_element %type "DataFileValue *"
:
    key_pair:key_pair
    {
        return key_pair;
    }
|
    value:value
    {
        return value;
    }
;

value %type "DataFileValue *"
:
    BOOLEAN:value
    {
        return value;
    }
|
    INTEGER:value
    {
        return value;
    }
|
    FLOAT:value
    {
        return value;
    }
|
    CHARACTER:value
    {
        return value;
    }
|
    string:value
    {
        return value;
    }
|
    structure:value
    {
        return value;
    }
|
    array:value
    {
        return value;
    }
/*
|
    %error
    {
        EmitError(FL, "syntax error in value");
        return NULL;
    }
*/
;

string %type "DataFileString *"
:
    string:string STRING_FRAGMENT:string_fragment
    {
        ASSERT1(string != NULL)
        ASSERT1(string_fragment != NULL)
        string->AppendString(string_fragment->GetValue());
        Delete(string_fragment);
        return string;
    }
|
    STRING_FRAGMENT:string_fragment
    {
        ASSERT1(string_fragment != NULL)
        return string_fragment;
    }
;
