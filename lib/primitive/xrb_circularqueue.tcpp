// ///////////////////////////////////////////////////////////////////////////
// xrb_circularqueue.tcpp by Victor Dods, created 2005/02/08
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

// this file is included by xrb_circularqueue.h, inside of namespace Xrb

template <typename T, Uint32 queue_size>
CircularQueue<T, queue_size>::CircularQueue ()
{
    ASSERT1(queue_size > 0);
    m_head = 0;
    m_tail = 0;
    m_entry_count = 0;
}

template <typename T, Uint32 queue_size>
CircularQueue<T, queue_size>::~CircularQueue ()
{
    m_head = 0;
    m_tail = 0;
    m_entry_count = 0;
}

template <typename T, Uint32 queue_size>
T const &CircularQueue<T, queue_size>::GetEntry (Uint32 const index) const
{
    ASSERT1(index < GetEntryCount());
    return m_queue[(m_head + index) % queue_size];
}

template <typename T, Uint32 queue_size>
void CircularQueue<T, queue_size>::Enqueue (T const &entry)
{
    ASSERT0(!GetIsFull());

    // add the entry
    m_queue[m_tail] = entry;
    // increment the tail index
    m_tail = GetIncrementedIndex(m_tail);
    // increment the number of entries
    ++m_entry_count;
}

template <typename T, Uint32 queue_size>
T CircularQueue<T, queue_size>::Dequeue ()
{
    ASSERT0(!GetIsEmpty());

    // save off the current head index so we know what to return
    Uint32 retval_index = m_head;
    // increment the head index
    m_head = GetIncrementedIndex(m_head);
    // decrement the number of entries
    --m_entry_count;

    // return the entry at the saved off index
    return m_queue[retval_index];
}

template <typename T, Uint32 queue_size>
void CircularQueue<T, queue_size>::Clear ()
{
    // reset the head index
    m_head = 0;
    // reset the tail index
    m_tail = 0;
    // reset the entry count
    m_entry_count = 0;
}
