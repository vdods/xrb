//////////////////////////////////////////////////////////////////////////////
// xrb_eventqueue.tcpp by Victor Dods, created 2005/11/07
//////////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
//////////////////////////////////////////////////////////////////////////////

// this file is included in xrb_eventqueue.h, inside the namespace Xrb

template <typename ParameterType>
void EventQueue::ScheduleMatchingEventsForDeletion (
    bool (*EventMatchingFunction)(Event const *, ParameterType),
    ParameterType parameter)
{
    // check all enqueued events against the given event-matching function.
    for (TimeOrderedEventBindingSet::iterator it = m_time_ordered_event_queue.begin(),
                                            it_end = m_time_ordered_event_queue.end();
         it != it_end;
         ++it)
    {
        Event const *event = it->GetEvent();
        ASSERT1(event != NULL);
        // only check events that aren't already scheduled for deletion
        if (!event->IsScheduledForDeletion())
            // if the function indicates a match, schedule the event for deletion
            if (EventMatchingFunction(event, parameter))
                event->ScheduleForDeletion();
    }
}

template <typename Parameter1Type, typename Parameter2Type>
void EventQueue::ScheduleMatchingEventsForDeletion (
    bool (*EventMatchingFunction)(Event const *, Parameter1Type, Parameter2Type),
    Parameter1Type parameter1,
    Parameter2Type parameter2)
{
    // check all enqueued events against the given event-matching function.
    for (TimeOrderedEventBindingSet::iterator it = m_time_ordered_event_queue.begin(),
                                            it_end = m_time_ordered_event_queue.end();
         it != it_end;
         ++it)
    {
        Event const *event = it->GetEvent();
        ASSERT1(event != NULL);
        // only check events that aren't already scheduled for deletion
        if (!event->IsScheduledForDeletion())
            // if the function indicates a match, schedule the event for deletion
            if (EventMatchingFunction(event, parameter1, parameter2))
                event->ScheduleForDeletion();
    }
}
